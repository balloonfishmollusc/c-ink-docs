# 用ink书写

目录

  * [介绍](#introduction)
  * [第一部分：基础知识](#part-one-the-basics)
    * [1) 内容](#1-内容)
    * [2) 选择](#2-选择)
    * [3) 结](#3-结)
    * [4) 分流](#4-分流)
    * [5) 分支流](#5-branching-the-flow)
    * [6) 包含和缝合](#6-includes-and-stitches)
    * [7) 不同的选择](#7-variing-choices)
    * [8) 变量文本](#8-variable-text)
    * [9) 游戏查询和函数](#9-game-queries-and-functions)
  * [第2部分：编织](#part-2-weave)
    * [1) 聚集](#1-聚集)
    * [2) 嵌套流](#2-nested-flow)
    * [3) 跟踪编织](#3-tracking-a-weave)
  * [第 3 部分：变量和逻辑](#part-3-variables-and-logic)
    * [1) 全局变量](#1-global-variables)
    * [2) 逻辑](#2-逻辑)
    * [3) 条件块 (if/else)](#3-conditional-blocks-ifelse)
    * [4) 临时变量](#4-temporary-variables)
    * [5) 函数](#5-函数)
    * [6) 常量](#6-常量)
    * [7) 高级：游戏端逻辑](#7-advanced-game-side-logic)
   * [第 4 部分：高级流量控制](#part-4-advanced-flow-control)
     * [1) 隧道](#1-隧道)
     * [2) 线程](#2-线程)
   * [第 5 部分：高级状态跟踪](#part-5-advanced-state-tracking)
     * [1) 基本列表](#1-basic-lists)
	 * [2) 重用列表](#2-reusing-lists)
	 * [3) 列出值](#3-list-values)
	 * [4) 多值列表](#4-multivalued-lists)
	 * [5) 高级列表操作](#5-advanced-list-operations)
	 * [6) 多列表列表](#6-multi-list-lists)
	 * [7) 长示例：犯罪现场](#7-long-example-crime-scene)
	 * [8) 摘要](#8-summary)
   * [第 6 部分：标识符中的国际字符支持](#part-6-international-character-support-in-identifiers)

＃ 介绍

**ink** 是一种脚本语言，它围绕使用流标记纯文本以生成交互式脚本的想法而构建。

在最基本的情况下，它可以用来编写一个选择你自己风格的故事，或者一个分支对话树。但它的真正优势在于编写有很多选项和大量流程重组的对话。

**ink** 提供了几个功能，使非技术作家能够经常分支，并以次要和主要方式发挥这些分支的后果，而无需大惊小怪。

该脚本旨在简洁且逻辑有序，因此可以“通过肉眼”测试分支对话。尽可能以声明方式描述流程。

它的设计也考虑到了重新起草；所以编辑流程应该很快。

＃ 第一部分：基础知识

## 1) 内容

### 最简单的ink脚本

最基本的ink脚本只是 .ink 文件中的文本。

	你好世界！

运行时，这将输出内容，然后停止。

单独行上的文本会产生新的段落。剧本：

	你好世界！
	你好？
	你好你在听吗？

产生看起来相同的输出。


＃＃＃ 注释

默认情况下，文件中的所有文本都将出现在输出内容中，除非特别标记。

最简单的标记是注释。**ink** 支持两种注释。有一种用于阅读代码的人，编译器会忽略它：

	“你怎么看这个？”她问。
	
	// 无法打印的东西...
	
	“我不可能发表评论，”我回答道。
	
	/*
		...或无限的文本块
	*/

还有一种用于提醒作者他们需要做什么，编译器在编译过程中打印出来：


	去做：正确写这部分！

### 标签

引擎运行时，游戏中的文本内容将“按原样”显示。但是，有时用额外的信息标记一行内容以告诉游戏如何处理该内容是有用的。

**ink** 提供了一个简单的系统，用于使用主题标签来标记内容行。

	一行正常的游戏文本。# 把它涂成蓝色

这些不会出现在主文本流中，但可以被游戏读出并在你认为合适的时候使用。有关详细信息，请参阅 [运行ink](RunningYourInk.md#marking-up-your-ink-content-with-tags)。


## 2) 选择

输入通过文本选择提供给玩家。文本选择由 `*` 字符指示。

如果没有给出其他流程指令，一旦做出，选择将流入下一行文本。

	你好世界！
	*你好回来！
		很高兴听到你的消息！

这将产生以下游戏：

	你好世界
	1：你好回来！
	
	&gt; 1
	你好回来！
	很高兴听到你的消息。

默认情况下，选择的文本会再次出现在输出中。

### 抑制选择文本

有些游戏将选择的文本与其结果分开。在 **ink** 中，如果选择文本在方括号中给出，则选择的文本将不会打印到响应中。

	你好世界！
	* [你好回来！]
		很高兴听到你的消息！

生产

	你好世界
	1：你好回来！
	
	&gt; 1
	很高兴听到你的消息。

#### 高级：混合选择和输出文本

方括号实际上划分了选项内容。在选择和输出中都打印了之前的内容；里面的东西只能选择；之后是什么，仅在输出中。实际上，它们提供了结束线路的替代方式。

	你好世界！
	*你好[回来！]马上回复你！
		很高兴听到你的消息！

产生：

	你好世界
	1：你好回来！
	&gt; 1
	你好马上回复你！
	很高兴听到你的消息。

这在编写对话选项时最有用：

	“那是什么？”我的主人问。
	* “我有点累了[.”]，”我重复道。
		“真的，”他回答。“多么有害。”

产生：

	“那是什么？”我的主人问。
	1.“我有些累了。”
	&gt; 1
	“我有点累了，”我重复道。
	“真的，”他回答。“多么有害。”

### 多项选择

为了做出真正的选择，我们需要提供替代方案。我们可以简单地通过列出它们来做到这一点：

	“那是什么？”我的主人问。
	* “我有点累了[.”]，”我重复道。
		“真的，”他回答。“多么有害。”
	* “没什么，先生！”[] 我回答。
		“那么很好。”
	*“我说过，这段旅程太可怕了[。”]我不想再这样了。”
		“啊，”他回答，并没有不客气。“我看你很沮丧。明天，情况会有所好转。”

这将产生以下游戏：

	“那是什么？”我的主人问。
	
	1：“我有些累了。”
	2：“没什么，先生！”
	3：“我说，这趟旅程太可怕了。”
	
	&gt; 3
	“我说，这段旅程太可怕了，我不想再这样了。”
	“啊，”他回答，并没有不客气。“我看你很沮丧。明天，情况会有所好转。”

上面的语法足以编写一组选择。在真实游戏中，我们希望根据玩家的选择将流程从一个点移动到另一个点。为此，我们需要引入更多结构。

## 3) 结

### 内容片段称为结

为了让游戏分支，我们需要用名称标记内容的部分（就像老式游戏本的“第 18 段”等）。

这些部分被称为“结”，它们是ink内容的基本结构单元。

### 写一个结

结的开始由两个或多个等号表示，如下所示。

	=== 顶结 ===

（末尾的等号是可选的；名称必须是一个没有空格的单词。）

结的开始是标头；接下来的内容将在那个结内。

	=== back_in_london ===
	
	我们正好在晚上 9.45 到达伦敦。

#### 高级：更复杂的“hello world”

启动ink文件时，结外的内容将自动运行。但结不会。所以如果你开始使用结来保存你的内容，你需要告诉游戏去哪里。我们使用转向箭头 `-&gt;` 来做到这一点，这将在下一节中正确介绍。

最简单的棘手脚本是：

	-&gt; top_knot
	
	=== 顶结 ===
	你好世界！

但是，**ink** 不喜欢松散的结尾，当它认为已经发生这种情况时，会在编译和/或运行时产生警告。上面的脚本在编译时产生了这个：

	警告：流量用完的地方存在明显的松散端。你需要一个&#39;-&gt; END&#39;语句，选择还是转移？在测试/test.ink 的第 3 行

这在运行：

	tests/test.ink 第 3 行中的运行时错误：内容用完。你需要&#39;-&gt; DONE&#39;还是&#39;-&gt; END&#39;？

以下播放和编译没有错误：

	=== 顶结 ===
	你好世界！
	-&gt; 结束

`-&gt; END` 是编写器和编译器的标记；这意味着“故事流程现在应该停止”。

## 4) 转移

### 结转向结

您可以使用“-&gt;”，一个“转移箭头”来讲述故事从一个结移动到另一个结。无需任何用户输入即可立即发生转移。

	=== back_in_london ===
	
	我们正好在晚上 9.45 到达伦敦。
	-&gt; hurry_home
	
	=== 快回家 ===
	我们以最快的速度赶回萨维尔街。

#### 转移是不可见的

转移是无缝的，甚至可以发生在句子中间：

	=== 快回家 ===
	我们赶紧回到萨维尔街 -&gt; as_fast_as_we_could
	
	=== as_fast_as_we_could ===
	尽可能快。

产生与上面相同的行：

	我们以最快的速度赶回萨维尔街。

＃＃＃＃ 胶水

默认行为在每行新内容之前插入换行符。然而，在某些情况下，内容必须坚持没有换行符，并且可以使用 `&lt;&gt;` 或“胶水”来做到这一点。

	=== 快回家 ===
	我们赶紧回家&lt;&gt;
	-&gt; to_savile_row
	
	=== to_savile_row ===
	到萨维尔街
	-&gt; as_fast_as_we_could
	
	=== as_fast_as_we_could ===
	&lt;&gt; 尽可能快。

还产生：

	我们以最快的速度赶回萨维尔街。

你不能使用太多的胶水：多个胶水并排没有额外的效果。（而且没有办法“否定”胶水；一旦一条线粘住了，它就会粘住。）


## 5) 分支流程

### 基本分支

结合结、选项和转向为我们提供了自选游戏的基本结构。

	=== 段落_1 ===
	你站在阿纳兰德的城墙旁，手持剑。
	* [打开大门] -&gt; 段落_2
	* [粉碎大门] -&gt; 段落_3
	* [转身回家] -&gt; 第4段
	
	=== 段落_2 ===
	你打开大门，踏上小路。
	
	...

### 分支和加入

使用转移，作者可以分支流程，然后重新加入，而无需向玩家显示流程已重新加入。

	=== back_in_london ===
	
	我们正好在晚上 9.45 到达伦敦。
	
	*“一刻也不能错过！”[]我宣布。
		-&gt; hurry_outside
	
	*“先生，让我们好好享受这一刻吧！”[]我宣布。
		我的主人狠狠地打了我一巴掌，把我拖出了门。
		-&gt; 拖到外面
	
	* [我们赶紧回家] -&gt; hurry_outside


	=== 快点外出 ===
	我们赶紧回到萨维尔街 -&gt; as_fast_as_we_could


	=== 拖到外面 ===
	他坚持要我们赶紧回家萨维尔街
	-&gt; as_fast_as_we_could


	=== as_fast_as_we_could ===
	&lt;&gt; 尽可能快。


###故事流程

结和分流结合起来创造了游戏的基本故事流程。这个流程是“平坦的” - 没有调用堆栈，并且不会“返回”转移。

在大多数ink脚本中，故事流程从顶部开始，像意大利面条一样乱七八糟地跳来跳去，最终，希望达到 `-&gt; END`。

非常松散的结构意味着作者可以继续写作、分支和重新加入，而不必担心他们正在创建的结构。创建新的分支或转移没有样板，也不需要跟踪任何状态。

＃＃＃＃ 先进的：循环

您绝对可以使用转移来创建循环内容，**ink** 有几个功能可以利用这一点，包括使内容自身变化的方法，以及控制选择选项频率的方法。

有关详细信息，请参阅有关更改文本和 [条件选择](#conditional-choices) 的部分。

哦，以下是合法的，不是一个好主意：

	=== 圆形 ===
	和
	-&gt; 圆形

## 6) 包括和缝合

### 结可以细分

随着故事变得越来越长，如果没有一些额外的结构，它们会变得更加混乱。

结可以包括称为“针”的子部分。这些使用单个等号标记。

	=== the_orient_express ===
	= in_first_class
		...
	= in_third_class
		...
	= in_the_guards_van
		...
	= 错过了火车
		...

例如，可以为场景使用结，为场景中的事件使用缝合线。

### 针迹具有唯一的名称

可以将针脚转移到使用其“地址”。

	* [乘坐三等舱]
		-&gt; the_orient_express.in_third_class
	
	* [乘坐警卫的面包车]
		-&gt; the_orient_express.in_the_guards_van

###第一针是默认的

转向包含针迹的结将转向结中的第一针。所以：

	* [头等舱旅行]
		“头等舱，先生。还有哪里？”
		-&gt; the_orient_express

是相同的：

	* [头等舱旅行]
		“头等舱，先生。还有哪里？”
		-&gt; the_orient_express.in_first_class

（......除非我们在结内移动针迹的顺序！）

您还可以在任何针迹之外的结顶部包含内容。但是，您需要记住转移它 - 一旦引擎通过标题内容工作，它*不会*自​​动进入第一针。

	=== the_orient_express ===
	
	我们上了火车，但在哪里？
	* [头等舱] -&gt; in_first_class
	* [二等] -&gt; in_second_class
	
	= in_first_class
		...
	= in_second_class
		...


### 本地转移

从一个结里面，你不需要使用完整的地址来缝合。

	-&gt; the_orient_express
	
	=== the_orient_express ===
	= in_first_class
		我安顿了我的主人。
		* [移动到三等]
			-&gt; in_third_class
	
	= in_third_class
		我把自己排在第三位。

这意味着针迹和结不能共享名称，但多个结可以包含相同的针迹名称。（所以东方快车和SS蒙古都可以坐头等舱。）

如果使用了不明确的名称，编译器会警告您。

### 脚本文件可以合并

您还可以使用 include 语句将内容拆分到多个文件中。

	包括报纸.ink
	包括城市/vienna.ink
	包括旅程/orient_express.ink

包含语句应该始终放在文件的顶部，而不是在结内。

没有关于结必须转移到哪个文件的规则。（换句话说，分离文件对游戏的命名空间没有影响）。


## 7) 不同的选择

###选项只能使用一次

默认情况下，游戏中的每个选项只能选择一次。如果您的故事中没有循环，您将永远不会注意到这种行为。但是如果你确实使用循环，你会很快注意到你的选项消失了......

	=== find_help ===
	
		你拼命地在人群中寻找一张友好的面孔。
		* 戴帽子的女人[?] 粗暴地把你推到一边。-&gt; 查找帮助
		* 当你跌跌撞撞地从他身边经过时，拿着公文包的男人[?] 看起来很反感。-&gt; 查找帮助

产生：

	你拼命地在人群中寻找一张友好的面孔。
	
	1：戴帽子的女人？
	2：那个拿着公文包的人？
	
	&gt; 1
	戴帽子的女人粗暴地把你推到一边。
	你拼命地在人群中寻找一张友好的面孔。
	
	1：那个拿着公文包的人？
	
	&gt;

...在下一个循环中，您将别无选择。

#### 后备选择

上面的例子停在原地，因为下一个选择最终会出现“内容不足”的运行时错误。

	&gt; 1
	当你跌跌撞撞地从他身边走过时，拿着公文包的男人看起来很反感。
	你拼命地在人群中寻找一张友好的面孔。
	
	tests/test.ink 第 6 行中的运行时错误：内容用完。你需要&#39;-&gt; DONE&#39;还是&#39;-&gt; END&#39;？

我们可以通过“后备选择”来解决这个问题。后备选项永远不会显示给玩家，但如果不存在其他选项，则由游戏“选择”。

后备选择只是“没有选择文本的选择”：

	* -&gt; out_of_options

而且，在稍微滥用语法的情况下，我们可以使用“选择然后箭头”来对其中的内容进行默认选择：

	* -&gt;
		Mulder永远无法解释他是如何从那辆燃烧的厢式车里出来的。-&gt; season_2

#### 后备选择示例

将其添加到前面的示例中会给我们：

	=== find_help ===
	
		你拼命地在人群中寻找一张友好的面孔。
		* 戴帽子的女人[?] 粗暴地把你推到一边。-&gt; 查找帮助
		* 当你跌跌撞撞地从他身边经过时，拿着公文包的男人[?] 看起来很反感。-&gt; 查找帮助
		* -&gt;
			但为时已晚：你倒在车站月台上。这就是结局。
			-&gt; 结束

并产生：

	你拼命地在人群中寻找一张友好的面孔。
	
	1：戴帽子的女人？
	2：那个拿着公文包的人？
	
	&gt; 1
	戴帽子的女人粗暴地把你推到一边。
	你拼命地在人群中寻找一张友好的面孔。
	
	1：那个拿着公文包的人？
	
	&gt; 1
	当你跌跌撞撞地从他身边走过时，拿着公文包的男人看起来很反感。
	你拼命地在人群中寻找一张友好的面孔。
	但为时已晚：你倒在车站月台上。这就是结局。


### 粘性选择

当然，“一次性”行为并不总是我们想要的，所以我们有第二种选择：“粘性”选择。粘性选择只是一个不会被用完的选择，并用 `+` 项目符号标记。

	=== homers_couch ===
		+ [再吃一个甜甜圈]
			你再吃一个甜甜圈。-&gt; homers_couch
		* [从沙发上下来]
			你挣扎着从沙发上爬起来去写史诗。
			-&gt; 结束

后备选择也可能很棘手。

	=== 对话循环
		* [谈论天气] -&gt; chat_weather
		* [谈论孩子] -&gt; chat_children
		+ -&gt; 再次静坐

### 条件选择

您也可以手动打开和关闭选择。**ink** 有很多可用的逻辑，但最简单的测试是“玩家是否看过特定的内容”。

游戏中的每个结/针都有一个唯一的地址（因此可以转移到），我们使用相同的地址来测试该内容是否已被看到。

	* { not visit_paris } [去巴黎] -&gt; visit_paris
	+ { visit_paris } [返回巴黎] -&gt; visit_paris
	
	* { visit_paris.met_estelle } [ 电话 Mme Estelle ] -&gt; phone_estelle

请注意，如果看到该结内的 *any* 针迹，则测试 `knot_name` 为真。

另请注意，条件不会覆盖选项的一次性行为，因此您仍然需要粘性选项来重复选择。

#### 高级：多个条件

您可以对一个选项使用多个逻辑测试；如果你这样做，*所有*测试必须全部通过才能出现选项。

	* { not visit_paris } [去巴黎] -&gt; visit_paris
	+ { visit_paris } { 不无聊_of_paris }
		[返回巴黎] -&gt; visit_paris

#### 逻辑运算符：AND 和 OR

上面的“多个条件”实际上只是具有通常编程 AND 运算符的条件。Ink 以通常的方式支持 `and`（也写为 `&amp;&amp;`）和 `or`（也写为 `||`），以及括号。

	* { 不是 (visit_paris 或 visit_rome) &amp;&amp; (visit_london || visit_new_york) } [ 等等。去哪里？我很困惑。] -&gt; 访问某个地方

对于非程序员来说，“X 和 Y”意味着 X 和 Y 都必须为真。`X 或 Y` 表示其中之一或两者。我们没有“异或”。

你也可以使用标准的 `!` 来表示 `not`，虽然它有时会混淆认为 `{!text}` 是一个一次性列表的编译器。我们推荐使用 `not`，因为否定的布尔测试从来没有那么令人兴奋。

#### 高级：结/针迹标签实际上是读取计数

考试：

	* {seen_clue} [指责杰斐逊先生]

实际上是在测试 *integer* 而不是真/假标志。以这种方式使用的结或针迹实际上是一个整数变量，包含玩家看到该地址内容的次数。

如果它不为零，它将在上述测试中返回 true，但您也可以更具体：

	* {seen_clue &gt; 3} [直接逮捕杰斐逊先生]


#### 高级：更多逻辑

**ink** 支持的逻辑和条件比此处介绍的要多 - 请参阅 [变量和逻辑](#part-3-variables-and-logic) 部分。


## 8) 可变文本

### 文字可以变化

到目前为止，我们看到的所有内容都是静态的、固定的文本片段。但内容在打印时也可能有所不同。

### 序列、循环和其他替代方案

最简单的文本变体由备选方案提供，这些备选方案根据某种规则进行选择。**ink** 支持多种类型。替代项写在 `{`...`}` 大括号内，元素由 `|` 符号（垂直分隔线）分隔。

只有当一个内容被多次访问时，这些才有用！

#### 替代品类型

**序列**（默认）：

序列（或“停止块”）是一组替代方案，用于跟踪其被看到的次数，并且每次都显示下一个元素。当它用完新内容时，它会继续显示最后一个元素。

	收音机发出嘶嘶声。{“三！”|“二！”|“一！”|有爆炸的白噪音。|但它只是静止的。}
	
	{我用五磅钞票买了一杯咖啡。|我为我的朋友买了第二杯咖啡。|我没有足够的钱再买咖啡。}

**循环**（标有 `&amp;`）：

循环就像序列，但它们循环它们的内容。

	今天是 {&amp;Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday}。


**仅一次**（标有 `!`）：

一次性替代方案类似于序列，但是当它们用完要显示的新内容时，它们什么也不显示。（您可以将仅一次的替代方案视为具有空白最后一个条目的序列。）

	他给我讲了一个笑话。{！我礼貌地笑了笑。|我笑了。|我做了个鬼脸。|我答应自己不要再有反应了。}

**随机播放**（标有`~`）：

随机播放产生随机输出。

	我扔了硬币。{~头|尾}。

#### 替代品的特点

备选方案可以包含空白元素。

	我向前迈了一步。{!||||然后灯灭了。-&gt; eek}

备选方案可以嵌套。

	Ratbear {&amp;{不浪费时间和|}滑动|划痕} {&amp;at you| into your {&amp;leg|arm|cheek}}。

替代方案可以包括转移语句。

	我{等了。|再等了一些。|打盹了。|醒来再等了。|放弃并离开了。-&gt; leave_post_office}

它们也可以在选择文本中使用：

	+ “你好，{&amp;Master|Monsieur Fogg|you|brown-eyes}！”[] 我宣布。

（...有一个警告；您不能以“{”开头选项的文本，因为它看起来像一个条件。）

（...但是需要注意的是，如果您在 `{` ink将其识别为文本之前转义了空格 `\ `。）

	+\ {&amp;他们前往沙地|他们出发前往沙漠|一行人沿着旧路向南}

＃＃＃＃ 例子

可以在循环内部使用替代方案来创建智能、状态跟踪游戏的外观，而无需特别努力。

这是whack-a-mole的单结版本。请注意，我们使用一次性选项和后备选项，以确保鼹鼠不会四处移动，并且游戏将永远结束。

	=== whack_a_mole ===
		{我举起锤子。|{~错过了！|没有！|不好。他在哪里？|啊哈！得到他！-&gt; 结束}}
		{&amp;mole|{&amp;nasty|blasted|foul} {&amp;creature|rodent}} {&amp;creature|rodent}} 正在{在这里某处|躲在某处|仍然逍遥法外|嘲笑我|仍然没有受到打击|注定要失败}。&lt;&gt;
		{！我会让他看看！|但这一次他不会逃跑的！}
		* [{&amp;Hit|Smash|Try} 左上角] -&gt; whack_a_mole
		* [{&amp;Whallop|Splat|Whack} 右上角] -&gt; whack_a_mole
		* [{&amp;Blast|Hammer} 中间] -&gt; whack_a_mole
		* [{&amp;Clobber|Bosh} 左下] -&gt; whack_a_mole
		* [{&amp;Nail|Thump} 右下角] -&gt; whack_a_mole
		* -&gt;
	    	    然后你会因饥饿而崩溃。鼹鼠打败了你！
	            -&gt; 结束


产生以下“游戏”：

	我举起锤子。
	鼹鼠就在这儿某处。我给他看！
	
	1：点击左上角
	2：狼牙右上角
	3：爆中
	4：Clobber 左下角
	5：钉在右下角
	
	&gt; 1
	错过了！
	这个讨厌的生物躲在某个地方。但这一次，他逃不掉了！
	
	1：右上角喷
	2：锤子中间
	3：波什左下角
	4：敲右下角
	
	&gt; 4
	没有什么！
	鼹鼠仍然逍遥法外。
	1：敲右上角
	2：爆中
	3：Clobber 左下角
	
	&gt; 2
	他在哪里？
	该死的啮齿动物在嘲笑我。
	1：狼牙右上角
	2：波什左下角
	
	&gt; 1
	啊哈！得到他！


这里有一些生活方式的建议。注意粘性选择 - 电视的诱惑永远不会消失：

	=== 打开电视 ===
	我打开电视{第一次|第二次|再一次|再一次}，但是没有什么好东西，所以我又把它关了|仍然没有什么值得看的|比以前更不吸引我的兴趣|只是垃圾|一个关于鲨鱼的节目，我不喜欢鲨鱼|什么都没有}。
	+ [再试一次] -&gt; turn_on_television
	* [改为外出] -&gt; go_outside_instead
	
	=== go_outside_instead ===
	-&gt; 结束



＃＃＃＃ 先睹为快：多线替代品
**ink** 也有另一种格式来替代不同的内容块。有关详细信息，请参阅有关 [多行块](#multiline-blocks) 的部分。



### 条件文本

文本也可以根据逻辑测试而有所不同，就像选项一样。

	{met_blofeld：“我看到了他。只是片刻。”}

和

	“他的真名是 {met_blofeld.learned_his_name: 弗朗茨|一个秘密}。”

这些可以显示为单独的行，也可以显示在内容的一部分中。它们甚至可以嵌套，所以：

	{met_blofeld：“我看到了他。只是片刻。他的真名是 {met_blofeld.learned_his_name: 弗朗茨|保守秘密}。”| “我想念他。他特别邪恶吗？”}

可以产生：

	“我看到了他。只是片刻。他的真名是弗兰兹。”

或者：

	“我看到了他。只是片刻。他的真名一直保密。”

或者：

	“我想念他。他特别邪恶吗？”

## 9) 游戏查询和函数

**ink** 提供了一些关于游戏状态的有用的“游戏级别”查询，用于条件逻辑。它们不是语言的一部分，但它们始终可用，并且作者无法编辑它们。从某种意义上说，它们是该语言的“标准库函数”。

惯例是以大写字母命名它们。

### CHOICE_COUNT()

`CHOICE_COUNT` 返回目前在当前块中创建的选项数量。比如说。

	* {false} 选项 A
	* {true} 选项 B
	* {CHOICE_COUNT() == 1} 选项 C

产生两个选项，B 和 C。这对于控制玩家在一个回合中获得多少选项很有用。

### 转（）

这将返回自游戏开始以来的游戏回合数。

### TURNS_SINCE（-&gt; 结）

`TURNS_SINCE` 返回自上次访问特定结/针以来的移动次数（正式地，玩家输入）。

值 0 表示“被视为当前块的一部分”。-1 的值表示“从未见过”。任何其他正值意味着它已经在很多回合前被看到。

	* {TURNS_SINCE(-&gt; sleep.intro) &gt; 10} 你感觉很累...-&gt; 睡觉
	* {TURNS_SINCE(-&gt; 笑) == 0} 你试着停止笑。

请注意，传递给 `TURNS_SINCE` 的参数是“转移目标”，而不仅仅是节点地址本身（因为节点地址是一个数字 - 读取计数 - 不是故事中的位置......）

去做：（将 `-c` 传递给编译器的要求）

#### 预览：在函数中使用 TURNS_SINCE

`TURNS_SINCE(-&gt;x) == 0` 测试非常有用，通常值得将其包装为一个ink函数。

	=== 函数 come_from(-&gt; x)
		~ 返回 TURNS_SINCE(x) == 0

关于 [functions](#5-functions) 的部分更清楚地概述了这里的语法，但上面允许您说如下内容：

	* {came_from(-&gt; nice_welcome)} &#39;我很高兴来到这里！&#39;
	* {came_from(-&gt; nasty_welcome)} &#39;让我们保持快速。&#39;

...并让游戏对玩家*刚刚*看到的内容做出反应。

### SEED_RANDOM()

出于测试目的，修复随机数生成器通常很有用，这样每次播放时 ink 都会产生相同的结果。您可以通过“播种”随机数系统来做到这一点。

	~ SEED_RANDOM(235)

您传递给种子函数的数字是任意的，但提供不同的种子将导致不同的结果序列。

#### 高级：更多查询

您可以创建自己的外部函数，尽管语法有点不同：请参阅下面的 [functions](#5-functions) 部分。


＃ 第2部分：编织

到目前为止，我们一直在以最简单的方式构建分支故事，使用“选项”链接到“页面”。

但这要求我们对故事中的每个目的地进行唯一的命名，这会减慢写作速度并阻止次要分支。

**ink** 有一个更强大的可用语法，旨在简化具有始终向前方向的故事流（就像大多数故事一样，而大多数计算机程序却没有）。

这种格式称为“编织”，它由基本的内容/选项语法构建而成，具有两个新功能：聚集标记，`-`，以及选择和聚集的嵌套。

## 1) 聚集

### 聚集点将流量聚集在一起

让我们回到本文档顶部的第一个多选示例。

	“那是什么？”我的主人问。
		* “我有点累了[.”]，”我重复道。
			“真的，”他回答。“多么有害。”
		* “没什么，先生！”[] 我回答。
		*“我说过，这段旅程太可怕了[。”]我不想再这样了。”
			“啊，”他回答，并没有不客气。“我看你很沮丧。明天，情况会有所好转。”

在真正的游戏中，所有这三个选项很可能会得出相同的结论——福格先生离开了房间。我们可以使用聚集来做到这一点，而无需创建任何新结或添加任何转向。

	“那是什么？”我的主人问。
		* “我有点累了[.”]，”我重复道。
			“真的，”他回答。“多么有害。”
		* “没什么，先生！”[] 我回答。
			“那么很好。”
		*“我说过，这段旅程太可怕了[。”]我不想再这样了。”
		“啊，”他回答，并没有不客气。“我看你很沮丧。明天，情况会有所好转。”
	
	——福格先生就这样离开了房间。

这会产生以下播放过程：

	“那是什么？”我的主人问。
	
	1：“我有些累了。”
	2：“没什么，先生！”
	3：“我说，这趟旅程太可怕了。”
	
	&gt; 1
	“我有点累了，”我重复道。
	“真的，”他回答。“多么有害。”
	福格先生说完就离开了房间。

### 选项和收集形式的内容链

我们可以将这些聚集和分支部分串在一起，形成始终向前运行的分支序列。

	=== 逃脱 ===
	我跑过森林，狗在我的脚后跟拍打。
	
		* 我检查了珠宝[] 是否还在我的口袋里，它们的触感让我的脚步不由自主地跳了起来。&lt;&gt;
	
		* 我没有停下来呼吸[]，而是继续奔跑。&lt;&gt;
	
		* 我高兴地欢呼。&lt;&gt;
	
	- 这条路不可能再远了！麦基会让引擎运转，然后我就安全了。
	
		* 我到了马路，看了看[]。你会相信吗？
		* 我应该打断说 Mackie 通常非常可靠[]。他从来没有让我失望过。或者更确切地说，在那天晚上之前，从来没有一次。
	
	- 这条路是空的。麦基不见了。

这是最基本的一种编织方式。本节的其余部分详细介绍了允许编织嵌套、包含侧轨和转移、转移自身的附加功能，最重要的是，参考早期的选择以影响以后的选择。

####编织理念

编织不仅仅是对分支流的方便封装；它们也是创作更强大内容的一种方式。上面的 `escape` 示例已经有四种可能的路线通过，而更复杂的序列可能还有很多很多。使用正常的转向，必须通过逐点追逐转向来检查链接，并且很容易出现错误。

通过编织，可以保证流动从顶部开始并“下降”到底部。基本编织结构中不可能出现流错误，并且可以轻松浏览输出文本。这意味着无需实际测试游戏中的所有分支以确保它们按预期工作。

编织还允许轻松重新起草选择点；特别是，出于多样性或节奏的原因，很容易分解句子并插入额外的选择，而无需重新设计任何流程。


## 2) 嵌套流

上面显示的编织是非常简单的“扁平”结构。无论玩家做什么，他们从上到下都需要相同的回合数。然而，有时某些选择需要更多的深度或复杂性。

为此，我们允许编织嵌套。

本节带有警告。嵌套编织非常强大且非常紧凑，但它们可能需要一点时间来适应！

### 选项可以嵌套

考虑以下场景：

	——“那么，波洛？谋杀还是自杀？”
	*“谋杀！”
	*“自杀！”
	- 克里斯蒂女士放下手稿片刻。写作组的其他人都坐着，张着嘴。

出现的第一个选项是“谋杀！”或“自杀！”。如果波洛宣布自杀，就没有什么可做的了，但在谋杀的情况下，需要一个后续问题——他怀疑谁？

我们可以通过一组嵌套的子选项添加新选项。我们通过使用两个星号而不是一个星号来告诉脚本这些新选择是另一个选择的“一部分”。


	——“那么，波洛？谋杀还是自杀？”
		*“谋杀！”
		 	“那是谁干的？”
			* * “侦探督察贾普！”
			* * “黑斯廷斯船长！”
			* * “我自己！”
		*“自杀！”
		- 克里斯蒂夫人放下手稿片刻。写作组的其他人都坐着，张着嘴。

（请注意，将行缩进以显示嵌套也是一种很好的风格，但编译器并不介意。）

如果我们想向另一条路线添加新的子选项，我们会以类似的方式进行。

	——“那么，波洛？谋杀还是自杀？”
		*“谋杀！”
		 	“那是谁干的？”
			* * “侦探督察贾普！”
			* * “黑斯廷斯船长！”
			* * “我自己！”
		*“自杀！”
			“真的吗，波洛？你确定吗？”
			* *  “非常肯定。”
			* * “这很明显。”
		- 克里斯蒂夫人放下手稿片刻。写作组的其他人都坐着，张着嘴。

现在，最初的指控选择将导致具体的后续问题 - 但无论哪种方式，流程都会在聚集点重新聚集，因为克里斯蒂夫人的客串亮相。

但是如果我们想要一个更扩展的子场景呢？

### 采集点也可以嵌套

有时，这不是增加选项数量的问题，而是增加不止一个故事节拍的问题。我们可以通过嵌套聚集点和选项来做到这一点。

	——“那么，波洛？谋杀还是自杀？”
			*“谋杀！”
			 	“那是谁干的？”
				* * “侦探督察贾普！”
				* * “黑斯廷斯船长！”
				* * “我自己！”
				- -  “你一定是在开玩笑！”
				* * “我，我是认真的。”
				* *  “要是...”
			*“自杀！”
				“真的吗，波洛？你确定吗？”
				* *  “非常肯定。”
				* * “这很明显。”
			- 克里斯蒂夫人放下手稿片刻。写作组的其他人都坐着，张着嘴。

如果玩家选择“谋杀”选项，他们将在他们的子分支上连续有两个选择 - 一个完整的平织，专为他们准备。

＃＃＃＃ 先进的：聚会做什么

聚会希望是直观的，但他们的行为有点难以用语言表达：一般来说，在选择了一个选项之后，故事会找到下一个不在较低级别的聚会，然后转向它。

基本思想是这样的：选项将故事的路径分开，然后将它们重新组合在一起。（因此得名“编织”！）


###您可以嵌套任意多个级别

上面，我们使用了两层嵌套；主流程和子流程。但是你可以去多少层没有限制。

	- “给我们讲个故事吧，船长！”
		*“很好，你们这些海狗。这是一个故事……”
			* *  “一个月黑风高的夜晚...”
					* * * “……船员们都很不安……”
							* * * * “……他们对他们的队长说……”
									* * * * * “……给我们讲个故事，队长！”
		*“不，已经过了你的就寝时间。”
	- 对一个男人来说，船员们开始打哈欠。

一段时间后，这种子嵌套变得难以阅读和操作，因此如果侧面选择变得笨拙，转移到新针迹是一种很好的风格。

但是，至少在理论上，你可以把你的整个故事写成一个单一的编织。

### 示例：具有嵌套节点的对话

这是一个更长的例子：

	- 我看着福格先生
	* ...我再也控制不住自己了。
		“我们这次旅行的目的是什么，先生？”
		“打赌，”他回答说。
		* * &#39;打赌！&#39;[] 我回来了。
				他点了点头。
				* * * “但那肯定是愚蠢的！”
				* * * &#39;那是最严重的事情！&#39;
				- - - 他又点了点头。
				* * * &#39;但我们能赢吗？
						“这就是我们将努力找出的问题，”他回答道。
				* * * &#39;一个适度的赌注，我相信？&#39;
						“两万英镑，”他断然回答。
				* * * 那时我没有再问他[.]，在最后一次礼貌的咳嗽之后，他没有再向我提供任何东西。&lt;&gt;
		* * &#39;Ah[.&#39;]，&#39;我回答，不确定我的想法。
		- - 之后，&lt;&gt;
	* ...但我什么也没说[]和&lt;&gt;
	——我们默默地度过了这一天。
	- -&gt; 结束

有几个可能的游戏。一个简短的：

	我看着福格先生
	
	1：……我再也控制不住自己了。
	2：...但我什么也没说
	
	&gt; 2
	...但我什么也没说，我们默默地度过了这一天。

还有一个更长的：

	我看着福格先生
	
	1：……我再也控制不住自己了。
	2：...但我什么也没说
	
	&gt; 1
	……我再也控制不住自己了。
	“我们这次旅行的目的是什么，先生？”
	“打赌，”他回答说。
	
	1：“打赌！”
	2：&#39;啊。&#39;
	
	&gt; 1
	“打赌！”我回来了。
	他点了点头。
	
	1：“但那肯定是愚蠢的！”
	2：“那是一件最严重的事情！”
	
	&gt; 2
	“那是一件最严重的事情！”
	他又点了点头。
	
	1：“但我们能赢吗？”
	2：“我相信，一个适度的赌注？”
	3：那时我没有再问他。
	
	&gt; 2
	“我相信，一个适度的赌注？”
	“两万英镑，”他断然回答。
	之后，我们就这样默默地度过了一天。

希望这能证明上述理念：编织提供了一种紧凑的方式来提供大量分支、大量选择，但保证从头到尾！


## 3) 跟踪编织

有时，编织结构就足够了。但如果不是，我们需要更多的控制。

### 编织在很大程度上没有得到解决

默认情况下，编织中的内容行没有地址或标签，这意味着它们不能被转移到，也不能被测试。在最基本的编织结构中，选择会改变玩家穿过编织的路径和他们看到的东西，但是一旦编织完成，这些选择和路径就会被遗忘。

但是如果我们想记住玩家看到的内容，我们可以——我们使用 `(label_name)` 语法在需要它们的地方添加标签。

### 集合和选项可以标记

可以使用括号标记任何嵌套级别的聚集点。

	-  （最佳）

一旦被标记，聚集点可以被转移到，或者在条件下进行测试，就像结和针一样。这意味着您可以使用先前的决策来改变编织内部的后期结果，同时仍然保持清晰、可靠的前向流动的所有优势。

选项也可以被标记，就像聚集点一样，使用括号。标签括号位于行中的条件之前。

这些地址可用于条件测试，这对于创建由其他选项解锁的选项很有用。

	=== meet_guard ===
	守卫皱着眉头看着你。
	
	*（问候）[问候他]
		&#39;问候。&#39;
	* (get_out) &#39;让开我的路[.&#39;]，&#39;你告诉守卫。
	
	- “嗯，”警卫回答。
	
	* {greet} &#39;今天过得愉快吗？// 仅当您向他打招呼时
	
	*“嗯？”[]你回答。
	
	* {get_out} [把他推到一边] // 仅当你威胁他时
		你狠狠地推了他一把。他凝视着回答，拔出了他的剑！
		-&gt; Fight_guard // 这条路线偏离了编织
	
	- &#39;Mff，&#39;警卫回答，然后给你一个纸袋。&#39;奶糖？&#39;


＃＃＃ 范围

在同一编织块内，您可以简单地使用标签名称；从块外部，您需要一条路径，或者到同一结内的不同针迹：

	=== 结 ===
	= 一针
		- （聚集点）一些内容。
	= 缝合两个
		* {stitch_one.gatherpoint} 选项

或指向另一个结：

	=== 结一个 ===
	- (gather_one)
		* {knot_two.stitch_two.gather_two} 选项
	
	=== 结_二 ===
	= 缝合两个
		- (gather_two)
			* {knot_one.gather_one} 选项


#### 高级：所有选项都可以标记

事实上，ink中的所有内容都是编织的，即使看不到任何聚集。这意味着您可以在游戏中使用括号标签标记 *any* 选项，然后使用寻址语法引用它。特别是，这意味着您可以测试玩家为达到特定结果而采取的*哪个*选项。

	=== 战斗守卫 ===
	...
	= throw_something
	* (rock) [向后卫投掷石块] -&gt; 投掷
	* (sand) [向守卫扔沙子] -&gt; throw
	
	=扔
	你向守卫投掷 {throw_something.rock:a rock|a一把沙子}。


＃＃＃＃ 先进的：编织中的循环

标签允许我们在编织内创建循环。这是向 NPC 提问的标准模式。

	- （选择）
		*“我可以从某个地方得到一件制服吗？”[]你问开朗的警卫。
			&#39;当然。在储物柜里。他咧嘴一笑。“不过，不要认为它适合你。”
		*“告诉我有关安全系统的信息。”
			“它很古老，”守卫向你保证。“像煤炭一样古老。”
		*“有狗吗？”
			“数百，”守卫回答，露出露齿的笑容。“还有饿鬼。”
		// 我们要求玩家至少问一个问题
		* {loop} [说够了]
			-&gt; 完成
	- （环形）
		// 在守卫感到无聊之前循环几次
		{ -&gt; 选择 | -&gt; 选择 | }
		他挠挠头。
		“好吧，不能整天站着说话，”他宣称。
	- （完毕）
		你谢过警卫，然后走开。





#### 高级：转向选项

选项也可以被转移到：但是转移到选择了那个选项的输出，*好像这个选项已经被选择了*。所以打印的内容会忽略方括号中的文字，如果选项是一次性的，会被标记为用完。

	- （选择）
	* [拉脸]
		你拉个脸，士兵就来找你！-&gt; 推
	
	*（推）[把守卫推到一边]你把守卫推到一边，但他回来摆动。
	
	* {shove} [格斗和战斗] -&gt; Fight_the_guard
	
	- -&gt; 选择

产生：

	1：做鬼脸
	2：把守卫推到一边
	
	&gt; 1
	你拉个脸，士兵就来找你！你把守卫推到一边，但他回来摆动。
	
	1：格斗和战斗
	
	&gt;

＃＃＃＃ 先进的：选择后直接聚集

以下是有效的，并且经常有用。

	* “你还好吗，先生？” [] 我问。
		——（很好）“很好，”他回答。
	* “先生，你填字游戏做得怎么样？”[]我问。
		-&gt; 很好
	* 我什么都没说[]，我的主人也没有。
	- 我们再次陷入了友善的沉默。

注意第一个选项正下方的 2 级收集点：这里没有什么可以收集的，真的，但它为我们提供了一个方便的地方来转移第二个选项。






# 第 3 部分：变量和逻辑

到目前为止，我们已经根据玩家迄今为止看到的内容使用测试来制作条件文本和条件选择。

**ink** 还支持临时变量和全局变量，用于存储数字和内容数据，甚至是故事流命令。它在逻辑方面功能齐全，并包含一些额外的结构，以帮助更好地组织分支故事的复杂逻辑。


## 1) 全局变量

最强大的一种变量，可以说是对故事最有用的变量，是一个变量，用于存储有关游戏状态的一些独特属性——从主角口袋里的钱数到表示主角状态的值。头脑。

这种变量被称为“全局”，因为它可以从故事中的任何地方访问——既可以设置，也可以从中读取。（传统上，编程试图避免这种事情，因为它允许程序的一部分与另一个不相关的部分混淆。但是一个故事就是一个故事，故事都是关于后果的：在维加斯发生的事情很少会停留在那里。）

### 定义全局变量

全局变量可以通过“VAR”语句在任何地方定义。它们应该被赋予一个初始值，它定义了它们是什么类型的变量——整数、浮点（十进制）、内容或故事地址。

	VAR Knowledge_of_the_cure = 假
	VAR player_name = &quot;艾米利亚&quot;
	VAR number_of_infected_people = 521
	VAR current_epilogue = -&gt; they_all_die_of_the_plague

### 使用全局变量

我们可以测试全局变量来控制选项，并提供条件文本，就像我们之前看到的那样。

	=== the_train ===
		火车颠簸着，嘎嘎作响。{心情&gt; 0：不过，我感觉很积极，并不介意奇怪的颠簸|这超出了我的承受能力}。
		* { not know_about_wager } &#39;但是，先生，我们为什么要旅行？&#39;[] 我问。
		* { know_about_wager} 我考虑了我们奇怪的冒险[]。这有没有可能？

#### 高级：将转移存储为变量

“转移”语句本身实际上是一种值，可以存储、更改和转移到。

	VAR current_epilogue = -&gt; 每个人都死了
	
	=== 继续或退出 ===
	现在放弃，还是继续努力拯救你的王国？
	*  [继续尝试！] 	-&gt; more_hopeless_introspection
	* [放弃] -&gt; current_epilogue


＃＃＃＃ 先进的：全局变量在外部可见

全局变量可以从运行时以及故事中访问和更改，因此提供了一种在更广泛的游戏和故事之间进行交流的好方法。

**ink** 层通常是存储游戏变量的好地方；没有需要考虑的保存/加载问题，故事本身可以对当前值做出反应。



### 打印变量

可以使用类似于序列的内联语法和条件文本将变量的​​值打印为内容：

	VAR friendly_name_of_player = &quot;杰基&quot;
	VAR 年龄 = 23
	
	我的名字是 Jean Passepartout，但我的朋友叫我 {friendly_name_of_player}。我 {age} 岁。

这在调试中很有用。有关基于逻辑和变量的更复杂的打印，请参阅函数部分。

### 评估字符串

可能会注意到，上面我们将变量称为能够包含“内容”，而不是“字符串”。这是故意的，因为在 ink 中定义的字符串可以包含 ink——尽管它总是会计算为字符串。（哎呀！）

	VAR a_color = &quot;&quot;
	
	~ a_colour = &quot;{~红色|蓝色|绿色|黄色}&quot;
	
	{a_color}

... 产生红色、蓝色、绿色或黄色中的一种。

请注意，一旦评估了这样的一段内容，它的值就是“粘性的”。（量子态崩溃。）所以以下内容：

	暴徒击中你，火花在你眼前飞舞，{a_colour} 和 {a_colour}。

...不会产生非常有趣的效果。（如果你真的想让它工作，使用文本函数来打印颜色！）

这也是为什么

	VAR a_colour = &quot;{~red|blue|green|yellow}&quot;

被明确禁止；它将根据故事的结构进行评估，这可能不是您想要的。


## 2) 逻辑

显然，我们的全局变量并不打算成为常量，所以我们需要一种语法来改变它们。

由于默认情况下，**ink** 脚本中的任何文本都直接打印到屏幕上，我们使用标记符号表示一行内容旨在进行一些数字工作，我们使用`~`标记。

以下语句都为变量赋值：


	=== set_some_variables ===
		~ know_about_wager = true
		~ x = (x * x) - (y * y) + c
		~ y = 2 * x * y

以下将测试条件：

	{ x == 1.2 }
	{ x / 2 &gt; 4 }
	{ y - 1 &lt;= x * x }

###数学

**ink** 支持四种基本数学运算（`+`、`-`、`*` 和 `/`），以及 `%`（或 `mod`），它返回整数除法后的余数。还有 POW 的权力：

	{POW(3, 2)} 是 9。
	{POW(16, 0.5)} 为 4。


如果需要更复杂的操作，可以编写函数（必要时使用递归），或调用外部游戏代码函数（用于任何更高级的操作）。


#### 随机（最小，最大）

如果需要，Ink 可以使用 RANDOM 函数生成随机整数。RANDOM 就像一个骰子（是的，吊坠，我们说 *a dice*），所以最小值和最大值都包含在内。

	~ temp dice_roll = RANDOM(1, 6)
	
	~ templazy_grading_for_test_paper = RANDOM(30, 75)
	
	~ temp number_of_heads_the_serpent_has = RANDOM(3, 8)

随机数生成器可以为测试目的播种，请参阅上面的游戏查询和函数部分。

#### 高级：数字类型是隐式的

运算结果——尤其是除法——是根据输入的类型进行分类的。所以整数除法返回整数，但浮点除法返回浮点结果。

	~ x = 2 / 3
	~ y = 7 / 3
	~ z = 1.2 / 0.5

指定 `x` 为 0，`y` 为 2，`z` 为 2.4。

＃＃＃＃ 先进的：INT()、FLOOR() 和 FLOAT()

如果您不想要隐式类型，或者想要对变量进行四舍五入，则可以直接对其进行强制转换。

	{INT(3.2)} 为 3。
	{FLOOR(4.8)} 为 4。
	{INT(-4.8)} 为 -4。
	{FLOOR(-4.8)} 为 -5。
	
	{FLOAT(4)} 是，嗯，还是 4。



### 字符串查询

奇怪的是，对于文本引擎来说，**ink** 并没有太多的字符串处理方式：假设您需要做的任何字符串转换都将由游戏代码（也可能由外部函数）处理。但是我们支持三个基本查询——相等、不等式和子字符串（我们称之为 ? 原因将在后面的章节中变得清楚）。

以下都返回真：

	{ “是的，请。”== “是的，请。”}
	{ “不，谢谢。”!= “是的，请。”}
	{ “是的，请” ？“舒适” }


## 3) 条件块（if/else）

我们已经看到用于控制选项和故事内容的条件； **ink** 还提供了一个等效的普通 if/else-if/else 结构。

### 一个简单的“如果”

if 语法从目前使用的其他条件中得到启发，`{`...`}` 语法表示正在测试某些东西。

	{ x &gt; 0:
		~ y = x - 1
	}

可以提供其他条件：

	{ x &gt; 0:
		~ y = x - 1
	- 别的：
		~ y = x + 1
	}

### 扩展 if/else if/else 块

上面的语法实际上是一个更通用结构的特定情况，类似于另一种语言的“switch”语句：

	{
		- x &gt; 0：
			~ y = x - 1
		- 别的：
			~ y = x + 1
	}

使用这种形式，我们可以包含“else-if”条件：

	{
		- x == 0：
			~ y = 0
		- x &gt; 0：
			~ y = x - 1
		- 别的：
			~ y = x + 1
	}

（注意，与其他所有内容一样，空格纯粹是为了便于阅读，没有语法意义。）

### 切换方块

还有一个实际的 switch 语句：

	{ X：
	- 0： 	零
	- 1： 	一
	- 2： 	二
	- 其他：很多
	}

#### 示例：上下文相关的内容

请注意，这些测试不必是基于变量的，并且可以使用读取计数，就像其他条件一样，并且以下构造非常频繁，以表示“做一些与当前游戏状态相关的内容“：

	===梦想===
		{
			-visited_snakes &amp;&amp; not dream_about_snakes：
				~ 恐惧++
				-&gt; dream_about_snakes
	
			-visited_poland &amp;&amp; not dream_about_polish_beer：
				~ 恐惧——
				-&gt; dream_about_polish_beer
	
			- 别的：
				// 早餐做梦没有效果
				-&gt; dream_about_marmalade
		}

该语法具有易于扩展和优先排序的优点。



### 条件块不限于逻辑

条件块可用于控制故事内容和逻辑：

	我盯着福格先生。
	{ know_about_wager：
		&lt;&gt; “但你肯定不是认真的吗？”我要求。
	- 别的：
		&lt;&gt; “但这次旅行一定有原因，”我观察到。
	}
	他什么也没说，只是认真地考虑他的报纸，就像昆虫学家考虑他最新的固定添加一样。

您甚至可以将选项放在条件块中：

	{ 门打开了：
		*我大步走出隔间[]，我想我听到我的主人在悄悄地自言自语。 			-&gt; 去外面
	- 别的：
		* 我请求允许离开[]，福格先生看起来很惊讶。 	-&gt; 开门
		* 我站起来去开门[]。福格先生似乎对这个小小的叛乱并不感到不安。-&gt; 开门
	}

...但请注意，上述示例中缺少编织语法和嵌套并非偶然：为避免在工作中混淆各种嵌套，您不得在条件块中包含聚集点。

### 多行块

还有另一类多行块，它从上面扩展了替代系统。以下所有内容都是有效的，并且可以执行您可能期望的操作：

 	// 顺序：遍历备选方案，并坚持最后一个
 	{停止：
 		- 我进入了赌场。
 		- 我又进了赌场。
 		- 再一次，我进去了。
 	}
 	
 	// 随机播放：随机显示一张
 	在桌子上，我抽了一张牌。&lt;&gt;
 	{洗牌：
 		- 红心王牌。
 		- 黑桃王。
 		- 2 颗钻石。
 			“这次你输了！”荷官叫道。
 	}
 	
 	// 循环：依次显示每个，然后循环
 	{ 循环：
 		- 我屏住呼吸。
 		- 我不耐烦地等待着。
 		- 我停了下来。
 	}
 	
 	// 一次：依次显示每个，一次，直到全部显示
 	{ 一次：
 		- 我的运气会保持吗？
 		- 我能赢吗？
 	}

#### 高级：修改后的随机播放

上面的shuffle block真的是一个“洗牌循环”；因为它会随机播放内容，播放它，然后重新洗牌并再次播放。

还有另外两个版本的 shuffle：

`shuffle once` 将随机播放内容，播放它，然后什么也不做。

	{ 洗牌一次：
	- 太阳很热。
	- 这是一个炎热的一天。
	}

`shuffle stop` 会随机播放所有内容（最后一个条目除外），一旦播放完毕，它会停留在最后一个条目上。

	{ 随机停止：
	- 一辆银色的宝马呼啸而过。
	- 轮到一辆亮黄色的野马。
	- 这里有汽车。
	}


## 4) 临时变量

### 临时变量用于临时计算

有时，全局变量很笨拙。**ink** 为快速计算事物提供临时变量。

	=== near_north_pole ===
		~ temp number_of_warm_things = 0
		{ 毯子：
			~ number_of_warm_things++
		}
		{耳罩：
			~ number_of_warm_things++
		}
		{ 手套：
			~ number_of_warm_things++
		}
		{ number_of_warm_things &gt; 2：
			尽管下雪了，但我感到无比舒适。
		- 别的：
			那天晚上，我比以往任何时候都更冷。
		}

在故事离开定义它的针脚后，临时变量中的值被丢弃。

### 结和针迹可以带参数

临时变量的一种特别有用的形式是参数。任何结或针迹都可以被赋予一个值作为参数。

	* [指责黑斯廷]
			-&gt; 指责（“黑斯廷斯”）
	* [指责布莱克夫人]
			-&gt; 指责（“克劳迪娅”）
	* [指责自己]
			-&gt; 指责（“我自己”）
	
	=== 指责（谁） ===
		“我指责{谁}！”波洛宣布。
		“真的？”贾普回答。“{谁 == “我自己”：你做的？|{谁}？}”
		“那么为何不？”波洛反击。


...如果要将临时值从一个针脚传递到另一个针脚，则需要使用参数！

#### 示例：递归结定义

临时变量在递归中使用是安全的（与全局变量不同），因此以下将起作用。

	-&gt; add_one_to_one_hundred(0, 1)
	
	=== add_one_to_one_hundred(total, x) ===
		~ 总计 = 总计 + x
		{ x == 100：
			-&gt; 完成（总计）
		- 别的：
			-&gt; add_one_to_one_hundred（总计，x + 1）
		}
	
	=== 完成（总计） ===
		“结果是 {total}！”你宣布。
		高斯惊恐地看着你。
		-&gt; 结束


（事实上​​，这种定义非常有用，**ink** 提供了一种特殊的结，足够想象，称为“函数”，它具有一定的限制并且可以返回一个值。请参阅下面的部分。）


#### 高级：发送转移目标作为参数

结/针地址是一种值，由 `-&gt;` 字符表示，可以存储和传递。因此，以下内容是合法的，并且通常很有用：

	=== sleep_in_hut ===
		你躺下，闭上眼睛。
		-&gt; generic_sleep (-&gt; waking_in_the_hut)
	
	=== generic_sleep (-&gt; 醒来)
		你睡觉可能会做梦等等等等。
		-&gt; 醒来
	
	=== waking_in_the_hut
		你重新站起来，准备继续你的旅程。

...但请注意 `generic_sleep` 定义中的 `-&gt;`：这是 **ink** 中需要输入参数的一种情况：因为很容易意外地执行以下操作：

	=== sleep_in_hut ===
		你躺下，闭上眼睛。
		-&gt; generic_sleep (waking_in_the_hut)

...它将“waking_in_the_hut”的读取计数发送到睡眠结，然后尝试转移到它。





## 5) 函数

在结上使用参数意味着它们几乎是通常意义上的函数，但它们缺少一个关键概念——调用堆栈和返回值的使用。

**ink** 包括功能：它们是结，具有以下限制和特点：

一个功能：
- 不能包含缝线
- 不能使用转移或提供选择
- 可以调用其他函数
- 可以包括印刷内容
- 可以返回任何类型的值
- 可以安全地递归

（其中一些可能看起来非常有限，但对于更多面向故事的调用堆栈风格的功能，请参阅 [Tunnels](#1-tunnels) 部分。）

返回值是通过 `~return` 语句提供的。

### 定义和调用函数

要定义一个函数，只需将一个结声明为一个：

	=== 功能 say_yes_to_everything ===
		~ 返回真
	
	=== 函数 lerp(a, b, k) ===
		~ 返回 ((b - a) * k) + a

函数通过名称和括号调用，即使它们没有参数：

	~ x = lerp(2, 8, 0.3)
	
	* {say_yes_to_everything()} &#39;是的。

与任何其他语言一样，函数一旦完成，就会将流返回到调用它的地方——尽管不允许转移流，函数仍然可以调用其他函数。

	=== 函数 say_no_to_nothing ===
		〜返回say_yes_to_everything（）

### 函数不必返回任何东西

函数不需要有返回值，可以简单地做一些值得打包的事情：

	=== 函数伤害(x) ===
		{ 耐力 &lt; x:
			〜耐力= 0
		- 别的：
			~ 耐力 = 耐力 - x
		}

...虽然记住一个函数不能转移，所以虽然上面的方法可以防止负的耐力值，但它不会杀死一个击中零的玩家。

### 函数可以内联调用

函数可以在 `~` 内容行上调用，但也可以在一段内容期间调用。在这种情况下，如果有返回值，则打印（以及函数想要打印的任何其他值。）如果没有返回值，则不打印任何内容。

默认情况下，内容是“粘合”的，因此如下：

	福格先生正在寻找{describe_health(health)}。
	
	=== 函数 describe_health(x) ===
	{
	- x == 100：
		〜返回“精灵”
	- x &gt; 75：
		〜返回“削片机”
	- x &gt; 45：
		〜返回“有点标记”
	- 别的：
		〜返回“沮丧”
	}

产生：

	福格先生看上去很沮丧。

＃＃＃＃ 例子

例如，您可能包括：

	=== 函数最大值(a,b) ===
		{ a &lt; b:
			~ 返回 b
		- 别的：
			~ 返回一个
		}
	
	=== 函数 exp(x, e) ===
		// 返回 x 的 e 次方，其中 e 是整数
		{ e &lt;= 0:
			〜返回1
		- 别的：
			~ 返回 x * exp(x, e - 1)
		}

然后：

	2^5 和 3^3 的最大值是 {max(exp(2,5), exp(3,3))}。

产生：

	2^5 和 3^3 的最大值为 32。


#### 示例：将数字变成单词

下面的例子很长，但几乎出现在迄今为止的所有 inkle 游戏中。（回想一下，多行花括号内的连字符表示“要测试的条件”，或者如果花括号以变量开头，则表示“要比较的值”。）

    === 函数 print_num(x) ===
    {
        - x &gt;= 1000：
            {print_num(x / 1000)} 千 { x mod 1000 &gt; 0:{print_num(x mod 1000)}}
        - x &gt;= 100：
            {print_num(x / 100)} 百 { x mod 100 &gt; 0:and {print_num(x mod 100)}}
        - x == 0：
            零
        - 别的：
            { x &gt;= 20:
                { x / 10:
                    - 2：二十
                    - 3：三十
                    - 4：四十
                    - 5：50
                    - 6：六十
                    - 7：七十
                    - 8：八十
                    - 9：九十
                }
                { x mod 10 &gt; 0:&lt;&gt;-&lt;&gt;}
            }
            { x &lt; 10 || x &gt; 20:
                { x mod 10:
                    - 1：一
                    - 2：两个
                    - 3：三
                    - 4：四个
                    - 5：五
                    - 6：六
                    - 7：7
                    - 8：八
                    - 9：9
                }
            - 别的：
                { X：
                    - 10：十
                    - 11：11
                    - 12：十二
                    - 13：十三
                    - 14：十四
                    - 15：十五
                    - 16：十六
                    - 17：十七
                    - 18：十八
                    - 19：十九
                }
            }
    }

这使我们能够编写如下内容：

	~ 价格 = 15
	
	我从口袋里掏出 {print_num(price)} 个硬币，慢慢数了数。
	“哦，没关系，”交易员回答。“我要一半。”她拿走了 {print_num(price / 2)}，把剩下的推给我。



### 参数可以通过引用传递

函数参数也可以“通过引用”传递，这意味着函数实际上可以更改传入的变量，而不是使用该值创建临时变量。

例如，大多数 **inkle** 故事包括以下内容：

	===函数alter（参考x，k）===
		~ x = x + k

行如：

	~ 金 = 金 + 7
	~ 健康 = 健康 - 4

然后变成：

	〜改变（金，7）
	〜改变（健康，-4）

这更容易阅读，并且（更有用）可以内联完成以实现最大的紧凑性。

	* 我吃了一块饼干[]，感觉神清气爽。{改变（健康，2）}
	* 我给了福格先生[]一块饼干，他狼吞虎咽地狼吞虎咽。{改变（foggs_health，1）}
	- &lt;&gt; 然后我们继续上路。

如果需要，将简单的操作封装在函数中还可以提供一个简单的地方来放置调试信息。




## 6) 常量


### 全局常量

交互式故事通常依赖于状态机，跟踪一些更高级别的过程已经达到什么阶段。有很多方法可以做到这一点，但最方便的是使用常量。

有时，将常量定义为字符串很方便，因此您可以将它们打印出来，用于游戏或调试目的。

	const 黑斯廷斯 = &quot;黑斯廷斯&quot;
	CONST POIROT = &quot;波洛&quot;
	常量 JAPP = &quot;Japp&quot;
	
	VAR current_chief_suspect = 黑斯廷斯
	
	=== 审查证据 ===
		{ found_japps_bloodied_glove：
			~ current_chief_suspect = POIROT
		}
		当前嫌疑人：{current_chief_suspect}

有时给它们赋值很有用：

	常数 PI = 3.14
	常量 VALUE_OF_TEN_POUND_NOTE = 10

有时这些数字在其他方面也很有用：

	常量大厅 = 1
	常数楼梯 = 2
	CONST 走廊 = 3
	
	常量 HELD_BY_AGENT = -1
	
	VAR secret_agent_location = 大厅
	VAR 手提箱位置 = 走廊
	
	=== 报告进度 ===
	{ secret_agent_location == 手提箱位置：
		特工抢了行李箱！
		~ 手提箱位置 = HELD_BY_AGENT
	
	-secret_agent_location &lt; 手提箱位置：
		特工向前走。
		~ secret_agent_location++
	}

常量只是一种让您为故事状态提供易于理解的名称的方法。

## 7) 高级：游戏端逻辑

在 **ink** 引擎中提供游戏挂钩有两种核心方式。ink 中的外部函数声明允许您在游戏中直接调用 C# 函数，变量观察者是在修改 ink 变量时在游戏中触发的回调。这两个都在 [Running your ink](RunningYourInk.md) 中描述。

# 第 4 部分：高级流量控制


## 1) 隧道

**ink** 故事的默认结构是一个“扁平”的选择树，分支并重新连接在一起，也许是循环的，但故事总是“在某个地方”。

但是这种扁平结构使某些事情变得困难：例如，想象一个游戏，其中可能发生以下交互：

	=== crossing_the_date_line ===
	*“先生！”[]我突然惊恐地宣布。“我刚刚意识到。我们已经越过了国际日期变更线！”
	- 福格先生几乎没有抬起眉毛。“我已经适应了。”
	* 我擦了擦额头上的汗水[]。一种解脱！
	* 我点点头，不动声色[]。他当然有！
	* 我低声咒骂[]。再一次，我被贬低了！

...但它可能发生在故事的几个不同的地方。我们不想为每个不同的地方编写内容的副本，但是当内容完成后，它需要知道返回到哪里。我们可以使用参数来做到这一点：

	=== crossing_the_date_line(-&gt; return_to) ===
	...
	- -&gt; return_to
	
	...
	
	=== 外面_火奴鲁鲁 ===
	我们到达了檀香山大岛。
	——（后记）
		-&gt; 穿越日期线（-&gt; 完成）
	- （完毕）
		-&gt; 结束
	
	...
	
	=== outside_pitcairn_island ===
	小船顺着水面驶向小岛。
	——（后记）
		-&gt; 穿越日期线（-&gt; 完成）
	- （完毕）
		-&gt; 结束

这两个位置现在都调用并执行相同的故事流片段，但一旦完成，它们就会返回到下一个需要去的地方。

但是，如果被调用的故事部分更复杂怎么办——如果它跨越几个结怎么办？使用上述方法，我们必须不断地将“return-to”参数从一个结传递到另一个结，以确保我们始终知道从哪里返回。

因此，**ink** 通过一种新的转移方式将其集成到语言中，其功能类似于子程序，被称为“隧道”。

### 隧道运行子故事

隧道语法看起来像一个转移，最后有另一个转移：

	-&gt;crossing_the_date_line -&gt;

这意味着“做crossing_the_date_line 的故事，然后从这里继续”。

在隧道本身内部，语法从参数化示例中得到了简化：我们所做的就是使用 `-&gt;-&gt;` 语句结束隧道，这实际上意味着“继续”。

	=== crossing_the_date_line ===
	// 这是一个隧道！
	...
	- -&gt;-&gt;

请注意，隧道结没有这样声明，因此编译器不会检查隧道是否真的以 `-&gt;-&gt;` 语句结束，除非在运行时。因此，您需要仔细编写以确保所有流入隧道的流量确实会再次流出。

隧道也可以链接在一起，或者完成一个正常的分流：

	...
	// 这会运行隧道，然后转向“完成”
	-&gt; crossing_the_date_line -&gt; 完成
	...
	
	...
	//这运行一个隧道，然后另一个，然后转向“完成”
	-&gt; crossing_the_date_line -&gt; check_foggs_health -&gt; 完成
	...

隧道可以嵌套，所以以下是有效的：

	===平原===
	= night_time
		黑草在你脚下柔软。
		+ [睡眠]
			-&gt; sleep_here -&gt; wake_here -&gt; day_time
	= day_time
		是时候继续前进了。
	
	=== 唤醒这里 ===
		当太阳升起时，你会醒来。
		+ [吃点东西]
			-&gt; 吃东西 -&gt;
		+ [行动]
		- -&gt;-&gt;
	
	=== sleep_here ===
		你躺下，试着闭上眼睛。
		-&gt; 怪物攻击 -&gt;
		然后是时候睡觉了。
		-&gt; 梦想 -&gt;
		-&gt;-&gt;

... 等等。


＃＃＃＃ 先进的：隧道可以返回其他地方

有时，在一个故事中，事情会发生。所以有时隧道不能保证它总是想回到它原来的地方。**ink** 提供了一种语法，允许您“从隧道返回但实际上去其他地方”，但应谨慎使用，因为变得非常困惑的可能性确实非常高。

不过，在某些情况下它是必不可少的：

	=== fall_down_cliff 
	-&gt; 伤害(5) -&gt; 
	你还活着！你振作起来，继续前行。
	
	=== 伤害（x）
		〜耐力-= x 
		{ 耐力 &lt;= 0:
			-&gt;-&gt; 你死了
		}
	
	=== 你死了
	突然，你的周围出现了一道白光。手指从你的前额抬起一个目镜。“你输了，伙计。离开椅子。

即使在不太激烈的情况下，我们也可能想要打破结构：

	-&gt; talk_to_jim -&gt;
	 
	 === talk_to_jim
	 - （选择） 	
		* [询问经线花边] 
			-&gt; warp_lacells -&gt;
		* [询问护盾发生器] 
			-&gt; shield_generators -&gt;	
		* [别说话]
			-&gt;-&gt;
	 - -&gt; 选择 
	
	 = warp_lacells
		{盾牌发电机：-&gt;-&gt; 争论 }
		“不用担心经线鞋带。他们很好。”
		-&gt;-&gt;
	
	 = shield_generators
		{ warp_lacells ：-&gt;-&gt; 争论 }
		“忘掉护盾发生器吧。他们很好。”
		-&gt;-&gt;
	 
	 = 争论 
	 	“这些问题是怎么回事？”吉姆突然要求。 
	 	...
	 	-&gt;-&gt;

＃＃＃＃ 先进的：隧道使用调用堆栈

隧道位于调用堆栈上，因此可以安全地递归。


## 2) 线程

到目前为止，ink中的一切都是完全线性的，尽管有所有的分支和转移。但实际上，作者可以将故事“分叉”成不同的子部分，以涵盖更多可能的玩家行为。

我们称其为“线程”，尽管它并不是计算机科学家所说的真正意义上的线程：它更像是从不同的地方拼接新内容。

请注意，这绝对是一个高级功能：一旦涉及线程，工程故事就会变得更加复杂！

### 线程将多个部分连接在一起

线程允许您一次从多个来源编写内容部分。例如：

    == 线程示例 ==
    我头疼;穿线很难让你头疼。
    &lt;- 对话
    &lt;- 走路


    == 对话 ==
    对蒙蒂和我来说，这是一个紧张的时刻。
     *“你今天午餐吃什么？”[]我问。
        “垃圾邮件和鸡蛋，”他回答说。
     *“好天气，我们有，”[]我说。
        “我见过更好的，”他回答说。
     - -&gt; 房子
    
    ==走路==
    我们继续走在尘土飞扬的路上。
     * [继续走]
        -&gt; 房子
    
    ==房子==
    没多久，我们就到了他家。
    -&gt; 结束

它允许故事的多个部分组合成一个部分：

    我头疼;穿线很难让你头疼。
    对蒙蒂和我来说，这是一个紧张的时刻。
    我们继续走在尘土飞扬的路上。
    1：“今天中午吃了什么？”
    2：“天气不错，我们有，”
    3：继续走

在遇到诸如`&lt;-conversation`之类的线程语句时，编译器将分叉故事流。考虑的第一个分叉将在 `conversation` 运行内容，收集它找到的任何选项。一旦这里的流量用完，它就会运行另一个分叉。

所有内容都被收集并显示给玩家。But when a choice is chosen, the engine will move to that fork of the story and collapse and discard the others.

请注意，全局变量*不是*分叉的，包括节点和针迹的读取计数。

### 线程的使用

在正常情况下，可能永远不需要线程。

但是对于具有大量独立移动部件的游戏，线程很快就变得必不可少。想象一个游戏，其中角色在地图上独立移动：房间的主要故事中心可能如下所示：

	CONST 走廊 = 1
	常数办公室 = 2
	
	VAR player_location = 走廊
	VAR generals_location = 走廊
	VAR 医生位置 = 办公室
	
	== run_player_location
		{
			- player_location == 走廊：-&gt; 走廊
		}
	
	== 走廊 ==
		&lt;- characters_present（走廊）
		* [抽屉] -&gt; 检查抽屉
		* [衣柜] -&gt; 检查衣柜
		* [去办公室] -&gt; go_office
		- -&gt; run_player_location
	= 检查抽屉
		// ETC...
	
	// 这是线程，它混合了您目前与您共享房间的角色的对话。
	
	== characters_present（房间）
		{ generals_location == 房间：
			&lt;-general_conversation
		}
		{ 医生位置 == 房间：
			&lt;-医生对话
		}
		-&gt; 完成
	
	== general_conversation
		* [问将军关于血刀的事]
			“这生意不好，我可以告诉你。”
		- -&gt; run_player_location
	
	== 医生对话
		* [问医生关于血刀的事]
			“血没有什么奇怪的，是吗？”
		- -&gt; run_player_location



特别要注意的是，我们需要一种显式的方式来让已经走下支线的玩家返回主流程。在大多数情况下，线程要么需要一个参数来告诉它们返回到哪里，要么它们需要结束当前的故事部分。


### 侧线什么时候结束？

侧线程在处理流程用完时结束：请注意，它们会收集选项以供稍后显示（与隧道不同，隧道会收集选项，显示它们并跟随它们直到它们达到明确的返回，可能会在几个动作之后）。

有时一个线程没有可提供的内容——也许根本就没有与角色的对话，或者也许我们只是还没有写出来。在这种情况下，我们必须明确标记线程的结束。

如果我们不这样做，内容的结尾可能是一个故事错误或一个挂起的故事线程，我们希望编译器告诉我们这些。

### 使用`-&gt; DONE`

在我们想要标记线程结束的情况下，我们使用`-&gt; DONE`：意思是“流程故意在这里结束”。如果我们不这样做，我们最终可能会收到一条警告消息——我们仍然可以玩游戏，但它提醒我们还有未完成的工作。

本节开头的示例将生成警告；它可以固定如下：

    == 线程示例 ==
    我头疼;穿线很难让你头疼。
    &lt;- 对话
    &lt;- 走路
    -&gt; 完成

额外的 DONE 告诉 ink 这里的流程已经结束，它应该依赖线程来完成故事的下一部分。

请注意，如果流程以不符合条件的选项结束，我们不需要 `-&gt; DONE`。引擎将此视为有效的、有意的、流结束状态。

**选择选项后，您不需要 `-&gt; DONE`**。一旦选择了一个选项，一个线程就不再是一个线程——它再次成为正常的故事流程。

在这种情况下使用 `-&gt; END` 不会结束线程，而是整个故事流程。（这就是有两种不同方式结束流量的真正原因。）


#### 示例：在多个地方添加相同的选择

线程可用于将相同的选择添加到许多不同的地方。以这种方式使用它们时，通常会传递一个转移作为参数，以讲述选择完成后要去哪里的故事。

	=== outside_the_house
	前一步。屋子里有味道。谋杀的。还有薰衣草。
	- （顶部）
		&lt;- review_case_notes(-&gt; 顶部)
		* [穿过前门]
			我走进屋里。
			-&gt; the_hallway
		* [闻空气]
			我讨厌薰衣草。它让我想起肥皂，肥皂让我想起我的婚姻。
			-&gt; 顶部
	
	=== the_hallway
	走廊。前门开向街道。小局。
	- （顶部）
		&lt;- review_case_notes(-&gt; 顶部)
		* [穿过前门]
			我走到凉爽的阳光下。
			-&gt; outside_the_house
		* [开局]
			钥匙。更多键。更多的钥匙。这些人需要多少把锁？
			-&gt; 顶部
	
	=== review_case_notes(-&gt; go_back_to)
	+ {未完成 || TURNS_SINCE(-&gt; 完成) &gt; 10}
		[查看我的案例笔记]
		// 条件确保您不会获得重复检查的选项
	 	{I|再一次，我}翻阅了我到目前为止所做的笔记。仍然没有明显的嫌疑人。
	-（完成）-&gt; go_back_to

请注意，这与隧道不同，隧道运行相同的内容块，但不给玩家选择。所以像这样的布局：

	&lt;-童年记忆（-&gt;下一个）
	* [看窗外]
	 	当我们滚来滚去时，我做着白日梦……
	 - （下一个）然后哨声响起......

可能会做同样的事情：

	* [记得我的童年]
		-&gt; think_back -&gt;
	* [看窗外]
		当我们滚来滚去时，我做着白日梦……
	- （下一个）然后哨声响起......

但是，一旦线程中的选项包括多个选择，或选择的条件逻辑（或任何文本内容，当然！），线程版本就变得更加实用。


#### 示例：广泛选择点的组织

使用ink作为脚本而不是文字输出的游戏通常可能会生成大量并行选择，旨在由玩家通过其他一些游戏内交互（例如在环境中走动）进行过滤。在这些情况下，线程可以用于简单地划分选择。

```
=== the_kitchen
- （顶部）
	&lt;- 抽屉（-&gt; 顶部）
	&lt;- 橱柜（-&gt; 顶部）
	&lt;- room_exits
= 抽屉 (-&gt; goback)
	// 关于抽屉的选择...
	...
= 橱柜（-&gt; goback）
	//关于橱柜的选择
	...
= room_exits
	// 退出；不需要“返回点”，就像你离开一样，你去别处
	...
```

# 第 5 部分：高级状态跟踪

具有大量交互的游戏可能会变得非常复杂、非常迅速，而作者的工作通常与保持内容的连续性一样重要。

如果游戏文本旨在模拟任何事物——无论是纸牌游戏、玩家目前对游戏世界的了解，还是房屋中各种电灯开关的状态，这一点就变得尤为重要。

**ink** 没有以经典解析器 IF 创作语言的方式提供完整的世界建模系统 - 没有“对象”，没有“包含”或“打开”或“锁定”的概念。然而，它确实提供了一个简单而强大的系统，以非常灵活的方式跟踪状态变化，使作者能够在必要时近似世界模型。

＃＃＃＃ 笔记：新功能提醒​​！

此功能对于该语言来说是非常新的。这意味着我们还没有开始发现它的所有可能使用方式 - 但我们很确定它会很有用！因此，如果您想到一个聪明的用法，我们很想知道！


## 1) 基本列表

状态跟踪的基本单元是状态列表，使用“LIST”关键字定义。请注意，列表实际上与 C# 列表（它是一个数组）完全不同。

例如，我们可能有：

	LISTkettleState = 冷、沸腾、最近煮沸

这一行定义了两件事：首先是三个新值——“cold”、“boiling”和“recently_boiled”——其次，一个名为“kettleState”的变量来保存这些状态。

我们可以告诉列表取什么值：

	〜水壶状态=冷

我们可以改变值：

	* [打开水壶]
		水壶开始冒泡并沸腾。
		~kettleState = 沸腾

我们可以查询值：

	* [触摸水壶]
		{水壶状态==冷：
			水壶摸起来很凉。
		- 别的：
		 	水壶的外面很暖和！
		}

为方便起见，我们可以在使用方括号定义列表时为其赋值：

	列表kettleState =冷，（沸腾），recently_boiled
	// 在游戏开始时，此水壶已打开。急躁吧？

...如果它的符号看起来有点多余，那么在几个小节的时间里出现这种情况是有原因的。



## 2) 重用列表

上面的例子对于水壶来说很好，但是如果我们在炉子上也有一个锅呢？然后我们可以定义一个状态列表，但将它们放入变量中 - 以及我们想要的任意数量的变量。

	LIST daysOfTheWeek = 周一、周二、周三、周四、周五
	今天的 VAR = 星期一
	VAR 明天 = 周二

### 状态可以重复使用

这允许我们在多个地方使用相同的状态机。

	列表加热水状态 = 冷、沸腾、最近煮沸
	VAR 水壶状态 = 冷
	VAR potState = 冷
	
	* {kettleState == 冷} [打开水壶]
		水壶开始沸腾并冒泡。
		~kettleState = 沸腾
	* {potState == 冷} [光炉]
	 	锅里的水开始沸腾并冒泡。
	 	~ potState = 沸腾

但是如果我们也加一个微波炉呢？我们可能想开始概括一下我们的功能：

	列表加热水状态 = 冷、沸腾、最近煮沸
	VAR 水壶状态 = 冷
	VAR potState = 冷
	VAR 微波状态 = 冷
	
	===函数boilSomething（参考thingToBoil，nameOfThing）
		{nameOfThing} 开始升温。
		~ thingToBoil = 沸腾
	
	=== do_cooking
	* {kettleState == 冷} [打开水壶]
		{boilSomething（kettleState，“水壶”）}
	* {potState == 冷} [光炉]
		{boilSomething(potState, &quot;pot&quot;)}
	* {microwaveState == cold} [打开微波炉]
		{boilSomething（microwaveState，“微波”）}

甚至...

	列表加热水状态 = 冷、沸腾、最近煮沸
	VAR 水壶状态 = 冷
	VAR potState = 冷
	VAR 微波状态 = 冷
	
	=== cook_with(nameOfThing, ref thingToBoil)
	+ {thingToBoil == 冷} [打开 {nameOfThing}]
	  	{nameOfThing} 开始升温。
		~ thingToBoil = 沸腾
		-&gt; do_cooking.done
	
	=== do_cooking
	&lt;- cook_with(&quot;水壶&quot;,kettleState)
	&lt;- cook_with(&quot;pot&quot;, potState)
	&lt;-cook_with(&quot;微波炉&quot;,微波状态)
	- （完毕）

请注意，“heatedWaterStates”列表仍然可用，并且仍然可以测试，并取一个值。

#### 列表值可以共享名称

重用列表会带来歧义。如果我们有：

	列表颜色 = 红色、绿色、蓝色、紫色
	LIST moods = 疯狂、快乐、忧郁
	
	VAR状态=蓝色

...编译器怎么知道你指的是哪个蓝色？

我们使用类似于结和针的语法来解决这些问题。

	VAR 状态 = colours.blue

...并且编译器将发出错误，直到您指定为止。

注意状态的“姓氏”和包含状态的变量是完全分开的。所以

	{ statesOfGrace == statesOfGrace.fallen:
		// 是当前状态“fallen”
	}

... 是正确的。


#### 高级：LIST 实际上是一个变量

一个令人惊讶的特点是声明

	LIST statesOfGrace = 模棱两可的、圣洁的、堕落的

实际上同时做两件事：它创建三个值，`ambiguous`、`saintly` 和 `fallen`，并在需要时给它们命名父 `statesOfGrace`；它创建了一个名为“statesOfGrace”的变量。

该变量可以像普通变量一样使用。所以以下是有效的，如果非常混乱和一个坏主意：

	LIST statesOfGrace = 模棱两可的、圣洁的、堕落的
	
	~ statesOfGrace = 3.1415 // 将变量设置为数字而不是列表值

...并且它不会排除以下情况：

	~ temp anotherStateOfGrace = statesOfGrace.saintly




## 3) 列出值

定义列表时，值按顺序列出，并且该顺序被认为是重要的。事实上，我们可以将这些值视为*是*数字。（也就是说，它们是枚举。）

	LIST volumeLevel = 关闭、安静、中等、响亮、震耳欲聋
	VAR 讲师音量 = 安静
	VAR murmurersVolume = 安静
	
	{讲师音量&lt;震耳欲聋：
		~ 讲师Volume++
	
		{讲师音量&gt; murmurers音量：
			~ murmurersVolume++
			喃喃的声音越来越大。
		}
	}

可以使用通常的 `{...}` 语法打印值本身，但这将打印它们的名称。

	讲师的声音变为 {lecturersVolume}。

### 将值转换为数字

如果需要，可以使用 LIST_VALUE 函数显式获取数值。请注意，列表中的第一个值的值为 1，而不是值 0。

	讲师仍有 {LIST_VALUE(deafening) - LIST_VALUE(lecturersVolume)} 个缺口可供他使用。

### 将数字转换为值

您可以通过将列表的名称用作函数来采用另一种方式：

	LIST Numbers = 一、二、三
	VAR分数=一
	~ score = Numbers(2) // 分数将为“二”

### 高级：定义自己的数值

默认情况下，列表中的值从 1 开始，每次递增 1，但如果需要，您可以指定自己的值。

	LIST primeNumbers = 二 = 2，三 = 3，五 = 5

如果您指定了一个值，但没有指定下一个值，则 ink 将假定增量为 1。所以下面是一样的：

	LIST primeNumbers = 二 = 2、三、五 = 5


## 4) 多值列表

下面的例子都包含了一个故意的谎言，我们现在将删除它。列表 - 以及包含列表值的变量 - 不必只包含一个值。

### 列表是布尔集

列表变量不是包含数字的变量。相反，列表就像住宿区中的进出名牌。它包含一个名称列表，每个名称都有一个与之关联的房间号，以及一个用于表示“in”或“out”的滑块。

也许没有人在：

	LIST DoctorsInSurgery = Adams、Bernard、Cartwright、Denver、Eamonn

也许每个人都是：

	LIST DoctorsInSurgery = (Adams), (Bernard), (Cartwright), (Denver), (Eamonn)

或者有些是有些不是：

	LIST DoctorsInSurgery = (Adams), Bernard, (Cartwright), Denver, Eamonn

括号中的名称包含在列表的初始状态中。

请注意，如果您要定义自己的值，则可以将括号括在整个术语或名称周围：

	LIST primeNumbers = (二 = 2), (三) = 3, (五 = 5)

#### 分配多个值

我们可以一次分配列表的所有值，如下所示：

	~ DoctorsInSurgery =（亚当斯，伯纳德）
	~ DoctorsInSurgery = (Adams, Bernard, Eamonn)

我们可以分配空列表来清除列表：

	~ DoctorsInSurgery = ()


#### 添加和删除条目

可以单独或共同添加和删除列表条目。

	~ DoctorsInSurgery = DoctorsInSurgery + Adams
	~ DoctorsInSurgery += Adams // 这和上面的一样
	~ DoctorsInSurgery -= 埃蒙
	~ DoctorsInSurgery += (Eamonn, 丹佛)
	~ DoctorsInSurgery -= (Adams, Eamonn, Denver)

尝试添加已在列表中的条目不会执行任何操作。尝试删除不存在的条目也无济于事。两者都不会产生错误，并且列表永远不能包含重复的条目。


### 基本查询

我们有一些基本的方法来获取有关列表中内容的信息：

	LIST DoctorsInSurgery = (Adams), Bernard, (Cartwright), Denver, Eamonn
	
	{LIST_COUNT(DoctorsInSurgery)} // &quot;2&quot;
	{LIST_MIN(DoctorsInSurgery)} //“亚当斯”
	{LIST_MAX(DoctorsInSurgery)} //“卡特赖特”
	{LIST_RANDOM(DoctorsInSurgery)} //“亚当斯”或“卡特赖特”

#### 空虚测试

像 ink 中的大多数值一样，列表可以“按原样”进行测试，并且将返回 true，除非它为空。

	{ 外科医生：手术今天开放。|每个人都回家了。}

#### 测试完全相等

测试多值列表比单值列表稍微复杂一些。相等（`==`）现在意味着“设置相等” - 也就是说，所有条目都是相同的。

所以有人可能会说：

	{ DoctorsInSurgery ==（亚当斯，伯纳德）：
		亚当斯博士和伯纳德博士在一个角落里大声争吵。
	}

如果 Eamonn 博士也在其中，那么两人就不会争论，因为被比较的名单不会相等 - DoctorsInSurgery 将有一个 Eamonn 名单（亚当斯，伯纳德）没有。

不等于按预期工作：

	{ DoctorsInSurgery != (亚当斯, 伯纳德):
		至少亚当斯和伯纳德没有争吵。
	}

#### 测试遏制

如果我们只想简单地询问 Adams 和 Bernard 是否在场怎么办？为此，我们使用了一个新的运算符，`has`，也称为 `?`。

	{ 外科医生？（亚当斯，伯纳德）：
		亚当斯博士和伯纳德博士在一个角落里悄悄地争论着。
	}

`?` 也可以应用于单个值：

	{ DoctorsInSurgery 有 Eamonn：
		埃蒙博士正在擦眼镜。
	}

我们也可以用 `hasnt` 或 `!?`（不是 `?`）来否定它。请注意，这开始变得有点复杂，因为

	外科医生！？（亚当斯，伯纳德）

并不意味着亚当斯和伯纳德都不在场，只是他们不是*都*在场（并且在争论）。


#### 示例：基础知识追踪

多值列表的最简单用途是整齐地跟踪“游戏标志”。

	LIST Facts = (Fogg_is_fairly_odd), first_name_phileas, (Fogg_is_English)
	
	{事实？Fogg_is_fairly_odd：我礼貌地笑了笑。|我皱了皱眉。他是个疯子吗？}
	&#39;{事实？ first_name_phileas:Phileas|Monsieur}，真的！我哭了。

特别是，它允许我们在一行中测试多个游戏标志。

	{事实？（Fogg_is_English，Fogg_is_fairly_odd）：
		&lt;&gt; &#39;我知道英国人很奇怪，但这是*不可思议*！&#39;
	}


#### 示例：医生的手术

我们迟到了一个更完整的例子，所以这里有一个。

	LIST DoctorsInSurgery = (Adams), Bernard, Cartwright, (Denver), Eamonn
	
	-&gt; 等候室
	
	=== 函数 whos_in_today()
		今天在手术中的是{DoctorsInSurgery}。
	
	=== 功能医生输入（谁）
		{ 外科医生！？谁：
			~ DoctorsInSurgery += 谁
			{who} 博士慌乱地赶来。
		}
	
	=== 功能医生叶子（谁）
		{ 外科医生？谁：
			~ DoctorsInSurgery -= 谁
			{who} 博士离开去吃午饭。
		}
	
	=== 等候室
		{whos_in_today()}
		* [时间流逝...]
			{doctorLeaves(Adams)} {doctorEnters(Cartwright)} {doctorEnters(Eamonn)}
			{whos_in_today()}

这会产生：

	今天接受手术的是丹佛的亚当斯。
	
	&gt; 时间流逝...
	
	亚当斯博士离开去吃午饭。卡特赖特博士慌乱地赶来。埃蒙博士慌乱地赶来。
	
	今天在手术室的有卡特赖特、丹佛、埃蒙。

#### 高级：更好的列表打印

基本的列表打印对于在游戏中使用并不是特别有吸引力。以下是更好的：

	=== 函数 listWithCommas(list, if_empty)
	    {LIST_COUNT（列表）：
	    - 2：
	        	{LIST_MIN(list)} 和 {listWithCommas(list - LIST_MIN(list), if_empty)}
	    - 1：
	        	{列表}
	    - 0：
				{if_empty}
	    - 别的：
	      		{LIST_MIN(list)}, {listWithCommas(list - LIST_MIN(list), if_empty)}
	    }
	
	LIST favouriteDinosaurs = (剑龙), 腕龙, (甲龙), (pleiosaur)
	
	我最喜欢的恐龙是 {listWithCommas(favouriteDinosaurs, &quot;allexted&quot;)}。

拥有一个 is/are 函数可能也很有用：

	=== 函数是（列表）
		{LIST_COUNT(list) == 1:是|是}
	
	我最喜欢的恐龙 {isAre(favouriteDinosaurs)} {listWithCommas(favouriteDinosaurs, &quot;all灭绝&quot;)}。

并且是悬垂的：

	我最喜欢的恐龙{LIST_COUNT(favouriteDinosaurs) != 1:s} {isAre(favouriteDinosaurs)} {listWithCommas(favouriteDinosaurs, &quot;allexted&quot;)}。


#### 列表不需要有多个条目

列表不*必须*包含多个值。如果你想使用一个列表作为状态机，上面的例子都可以工作——使用 `=`、`++` 和 `--` 设置值；使用 `==`、`&lt;`、`&lt;=`、`&gt;` 和 `&gt;=` 测试它们。这些都将按预期工作。

### “完整”列表

请注意，`LIST_COUNT`、`LIST_MIN` 和 `LIST_MAX` 是指谁在/不在列表中，而不是*可能*医生的完整集合。我们可以使用

	LIST_ALL（列表的元素）

或者

	LIST_ALL（包含列表元素的列表）
	
	{LIST_ALL(DoctorsInSurgery)} // 亚当斯、伯纳德、卡特赖特、丹佛、埃蒙
	{LIST_COUNT(LIST_ALL(DoctorsInSurgery))} // &quot;5&quot;
	{LIST_MIN(LIST_ALL(Eamonn))} //“亚当斯”

请注意，使用 `{...}` 打印列表会生成列表的基本表示；值作为单词，用逗号分隔。

＃＃＃＃ 先进的：“刷新”列表的类型

如果你真的需要，你可以创建一个知道它是什么类型的列表的空列表。

	LIST ValueList = first_value, second_value, third_value
	VAR myList = ()
	
	~ myList = ValueList()

然后，您将能够：

	{ LIST_ALL(myList) }

#### 高级：“完整”列表的一部分

您还可以使用 `LIST_RANGE` 函数仅检索完整列表的“切片”。有两种说法，都有效：

	LIST_RANGE(list_name, min_integer_value, max_integer_value)

和

	LIST_RANGE(list_name, min_value, max_value)

这里的最小值和最大值包括在内。如果游戏找不到值，它会尽可能接近，但永远不会超出范围。例如：

	{LIST_RANGE(LIST_ALL(primeNumbers), 10, 20)} 

会产生 
	
	11、13、17、19



＃＃＃ 例子：河内塔

为了演示其中的一些想法，这里有一个功能性的河内塔示例，这样就不需要其他人来编写它了。


	LIST Discs = 一、二、三、四、五、六、七
	VAR post1 = ()
	VAR post2 = ()
	VAR post3 = ()
	
	~ post1 = LIST_ALL(光盘)
	
	- &gt;游戏循环
	
	=== 函数 can_move(from_list, to_list) ===
	    {
	    - LIST_COUNT(from_list) == 0:
	        // 没有要移动的磁盘
	        ~ 返回假
	    - LIST_COUNT(to_list) &gt; 0 &amp;&amp; LIST_MIN(from_list) &gt; LIST_MIN(to_list):
	        // 移动的圆盘比新塔上最小的圆盘大
	        ~ 返回假
	    -   别的：
	    	 // 没有什么能挡住你的路！
	        ~ 返回真
	
	    }
	
	===函数move_ring（参考来自，参考到）===
	    ~ temp whichRingToMove = LIST_MIN(from)
	    ~ 来自 -= whichRingToMove
	    ~ to += whichRingToMove
	
	== 函数 getListForTower(towerNum)
	    { 塔号：
	        - 1：    〜返回帖子1
	        - 2：    〜返回post2
	        - 3：    〜返回post3
	    }
	
	=== 函数名（postNum）
	    {postToPlace(postNum)} 神殿
	
	=== 函数名称（postNum）
	    {postToPlace(postNum)} 神殿
	
	=== 函数 postToPlace(postNum)
	    {邮编：
	        - 1：第一
	        - 2：第二
	        - 3：第三
	    }
	
	=== 函数 describe_pillar(listNum) ==
	    ~ 临时列表 = getListForTower(listNum)
	    {
	    - LIST_COUNT（列表）== 0：
	        {Name(listNum)} 为空。
	    - LIST_COUNT（列表）== 1：
	        {list} 环位于 {name(listNum)} 上。
	    - 别的：
	        在 {name(listNum)} 上，是编号为 {list} 的光盘。
	    }


	=== 游戏循环
	    从天而降，你会看到你的追随者完成了最后一座伟大的寺庙的建设，准备开始工作。
	- （顶部）
	    + [关于寺庙]
	        你依次观察每一座神殿。每个上面都堆放着石环。{describe_pillar(1)} {describe_pillar(2)} {describe_pillar(3)}
	    &lt;- move_post(1, 2, post1, post2)
	    &lt;- move_post(2, 1, post2, post1)
	    &lt;- move_post(1, 3, post1, post3)
	    &lt;- move_post(3, 1, post3, post1)
	    &lt;- move_post(3, 2, post3, post2)
	    &lt;- move_post(2, 3, post2, post3)
	    -&gt; 完成
	
	= move_post(from_post_num, to_post_num, 参考 from_post_list, 参考 to_post_list)
	    + { can_move(from_post_list, to_post_list) }
	        [将环从 {name(from_post_num)} 移动到 {name(to_post_num)} ]
	        { move_ring(from_post_list, to_post_list) }
	        {停止：
	        - 远在下方的祭司们建造了一个巨大的挽具，经过多年的工作，巨大的石环被举到空中，然后摆动到下一个寺庙。
	            绳索被斩断，眨眼之间又掉了下来。
	        - 你的下一个法令会遇到一个盛大的盛宴和许多牺牲。葬礼烟雾散去后，转移大石环的工作正式开始。一代人的成长和堕落，戒指落入其指定的位置。
	        -   {循环：
	            - 随着戒指慢慢移动，岁月流逝。
	            - 下面的祭司为穿什么颜色的长袍而战，但在他们倒下和死亡的同时，工作仍然完成。
	            }
	        }
	    -&gt; 顶部



## 5) 高级列表操作

上面的部分涵盖了基本的比较。还有一些更强大的功能，但是 - 正如任何熟悉数学集合的人都会知道的那样 - 事情开始变得有点复杂。因此，本节带有“高级”警告。

本节中的许多功能对于大多数游戏来说都不是必需的。

### 比较列表

我们可以使用 `&gt;`、`&lt;`、`&gt;=` 和 `&lt;=` 来比较不精确的列表。被警告！我们使用的定义并不完全是标准票价。它们基于比较被测试列表中元素的数值。

####“明显大于”

`LIST_A &gt; LIST_B`的意思是“A中的最小值大于B中的最大值”：换句话说，如果放在数轴上，整个A在整个B的右边。`&lt;`反过来做同样的事情。

####“绝对不会小于”

`LIST_A &gt;= LIST_B` 的意思是——现在深呼吸——“A 中的最小值至少是 B 中的最小值，A 中的最大值至少是 B 中的最大值”。也就是说，如果在数轴上绘制，整个 A 要么在 B 之上，要么与它重叠，但 B 不会延伸到高于 A。

请注意，`LIST_A &gt; LIST_B` 意味着 `LIST_A != LIST_B`，而 `LIST_A &gt;= LIST_B` 允许 `LIST_A == LIST_B` 但排除 `LIST_A &lt; LIST_B`，正如您可能希望的那样。

####健康警告！

`LIST_A &gt;= LIST_B` *不* 与 `LIST_A &gt; LIST_B 或 LIST_A == LIST_B` 相同。

道德是，除非你有一个清晰的画面，否则不要使用这些。

### 反转列表

列表可以“倒置”，这相当于通过住宿进/出名牌并将每个开关翻转到与以前相反的位置。

	LIST GuardsOnDuty = (Smith), (Jones), Carter, Braithwaite
	
	=== 功能改变OfTheGuard
		~ GuardsOnDuty = LIST_INVERT(GuardsOnDuty)


请注意，如果游戏没有足够的上下文来知道什么反转，空列表上的 `LIST_INVERT` 将返回一个空值。如果您需要处理这种情况，手动操作是最安全的：

	=== 功能改变OfTheGuard
		{!GuardsOnDuty：// “GuardsOnDuty 现在是空的吗？”
			〜GuardsOnDuty = LIST_ALL（史密斯）
		- 别的：
			~ GuardsOnDuty = LIST_INVERT(GuardsOnDuty)
		}

#### 脚注

反转的语法最初是 `~list` 但我们改变了它，因为否则行

	~ 清单 = ~ 清单

不仅是功能性的，而且实际上导致列表自身反转，这似乎过于反常。

### 相交列表

`has` 或 `?` 运算符更正式地说是“你是我的子集”运算符⊇，它包括相等的集合，但如果更大的集合不完全包含，则不包括较小的集合。

为了测试列表之间的“某些重叠”，我们使用重叠运算符 `^` 来获取 *intersection*。

	LIST CoreValues = 力量、勇气、同情心、贪婪、裙带关系、self_belief、delusions_of_godhood
	VAR desiredValues =（力量、勇气、同情心、self_belief）
	VAR实际值=（贪婪，裙带关系，self_belief，delusions_of_godhood）
	
	{desiredValues ^ actualValues} // 打印“self_belief”

结果是一个新列表，因此您可以对其进行测试：

	{期望值 ^ 实际值：新总统至少有一个值得称道的品质。}
	
	{LIST_COUNT(desiredValues ^ actualValues) == 1：更正一下，新总统只有一个可取的品质。{desiredValues ^ actualValues == self_belief: 这是最可怕的。}}




## 6) 多列表列表


到目前为止，我们所有的例子都包含了一个很大的简化——列表变量中的值必须全部来自同一个列表族。但他们没有。

这使我们可以使用列表——迄今为止，它扮演了状态机和标志跟踪器的角色——也可以作为通用属性，这对于世界建模很有用。

这是我们的成立时刻。结果是强大的，但也比以前的任何东西都更像“真实代码”。

### 跟踪对象的列表

例如，我们可以定义：

	LIST Characters = 阿尔弗雷德、蝙蝠侠、罗宾
	LIST Props = champagne_glass, 报纸
	
	VAR BallroomContents =（阿尔弗雷德、蝙蝠侠、报纸）
	VAR HallwayContents = (Robin, champagne_glass)

然后我们可以通过测试它的状态来描述任何房间的内容：

	=== 功能描述房间（房间状态）
		{房间状态？阿尔弗雷德：阿尔弗雷德在这里，静静地站在角落里。} { 房间状态？蝙蝠侠：蝙蝠侠的存在支配着一切。} { 房间状态？罗宾：罗宾几乎被遗忘了。}
		&lt;&gt; { 房间状态 ?香槟酒杯：一个香槟酒杯被丢弃在地板上。} { 房间状态？报纸：在一张桌子上，一个标题大声疾呼谁是蝙蝠侠？并且*谁*是他几乎不记得的助手？}

那么：

	{ describe_room(BallroomContents) }

产生：

	阿尔弗雷德在这里，静静地站在角落里。蝙蝠侠的存在支配着一切。
	
	在一张桌子上，一个标题大声疾呼谁是蝙蝠侠？并且*谁*是他几乎不记得的助手？

尽管：

	{ 描述房间（走廊内容） }

给出：

	罗宾几乎被遗忘了。
	
	一个香槟酒杯被丢弃在地板上。

我们可以有基于事物组合的选项：

	* { 当前房间状态？（蝙蝠侠，阿尔弗雷德）} [与阿尔弗雷德和蝙蝠侠交谈]
		“喂，你们两个认识吗？”

### 列表跟踪多个状态

我们可以对具有多种状态的设备进行建模。再次回到水壶...

	LIST OnOff = 开、关
	LIST HotCold = 冷、暖、热
	
	VAR 水壶状态 = 关，冷
	
	=== 函数 turnOnKettle() ===
	{水壶状态？热的：
		您打开水壶，但它立即再次关闭。
	- 别的：
		水壶里的水开始变热。
		〜水壶状态-=关闭
		~kettleState += on
		// 注意我们避免使用“=”，因为它会删除所有现有状态
	}
	
	=== 函数 can_make_tea() ===
		〜返回水壶状态？（热，关）

这些混合状态会使改变状态变得有点棘手，如上面的 off/on 所示，因此以下辅助函数可能很有用。

 	=== 函数 changeStateTo(ref stateVariable, stateToReach)
 		// 移除该类型的所有状态
 		~ stateVariable -= LIST_ALL(stateToReach)
 		// 放回我们想要的状态
 		~ stateVariable += stateToReach

 启用如下代码：

 	~ changeState(kettleState, on)
 	〜changeState（kettleState，温暖）


#### 这对查询有何影响？

上面给出的查询大多很好地推广到多值列表

    列出字母 = a,b,c
    LIST Numbers = 一、二、三
    
    VAR 混合列表 = (a, 三, c)
    
    {LIST_ALL(mixedList)} // a, 一, b, 二, c, 三
    {LIST_COUNT(mixedList)} // 3
    {LIST_MIN(mixedList)} // 一个
    {LIST_MAX(mixedList)} // 三个或 c，尽管不可预测
    
    {混合列表？(a,b) } // 假
    {mixedList ^ LIST_ALL(a)} // a, c
    
    { 混合列表 &gt;= (one, a) } // 真
    { mixedList &lt; (三) } // false
    
    { LIST_INVERT(mixedList) } // 一，二，二


## 7) 长示例：犯罪现场

最后，这是一个很长的示例，展示了本节中的许多想法。您可能想在通读之前尝试播放它，以更好地了解各种移动部件。

	-&gt; 谋杀现场
	
	// 辅助函数：从列表中弹出元素
	=== 函数弹出（参考列表）
	   〜温度x = LIST_MIN（列表） 
	   〜列表-= x 
	   ~ 返回 x
	
	//
	// 系统：物品可以有多种状态
	// 有些是通用的，有些是针对特定项目的
	//


	LIST OffOn = 关，开
	LIST SeenUnseen = 看不见的，看见的
	
	LIST GlassState = (none)、steamed、steam_gone
	LIST BedState = (made_up)、covers_shifted、covers_off、bloodstain_visible
	
	//
	// 系统：库存
	//
	
	LIST Inventory =（无），手杖，刀
	
	=== 函数获取（x）
	    ~ 库存 += x
	
	//
	// 系统：定位东西
	// 物品可以放在地方和地方
	//
	
	列表支持者 = on_desk、on_floor、on_bed、under_bed、holded、with_joe
	
	=== 函数 move_to_supporter(ref item_state, new_supporter) ===
	    ~ item_state -= LIST_ALL（支持者）
	    ~ item_state += new_supporter


​​​	
​ // 系统：增量知识。
​ // 每个列表都是一个事实链。每个事实都取代了之前的事实 
​ //
​​​	
	VAR 知识状态 = ()
	
	=== 达到功能 (x) 
	   ~ 返回知识状态？ X 
	
	=== (x, y) 之间的函数 
	   ~ 返回知识状态？ x &amp;&amp; not (knowledgeState ^ y)
	
	=== 功能到达（statesToSet） 
	   ~ temp x = pop(statesToSet)
	   {
	   - 不是 x： 
	      ~ 返回假 
	
	   - 未达到（x）：
	      ~ 临时链 = LIST_ALL(x)
	      〜临时状态增益= LIST_RANGE（链，LIST_MIN（链），x）
	      ~ KnowledgeState += statesGained
	      ~reach (statesToSet) // 设置剩下的任何其他状态
	      ~ return true // 我们设置了这个状态，所以 true
	 
	    - 别的：
	      〜返回假||到达（statesToSet） 
	    }	
	
	//
	// 设置游戏
	//
	
	VAR卧室LightState =（关闭，on_desk）
	
	VAR刀状态=（under_bed）


​​​	
​ //
​ // 知识链
​ //


​​​	
​ LIST BedKnowledge = 整齐地制造，弄皱的羽绒被，仓促地重新制造，身体上的床，谋杀的床，谋杀的同时睡眠
​​​	
	LIST KnifeKnowledge = prints_on_knife、joe_seen_prints_on_knife、joe_wants_better_prints、joe_got_better_prints
	
	LIST WindowKnowledge = steam_on_glass、fingerprints_on_glass、fingerprints_on_glass_match_knife


​​​	
​ //
​ // 内容
​ //
​​​	
	=== 谋杀现场 ===
	    卧室。这就是它发生的地方。现在寻找线索。
	- （顶部）
	    {卧室灯状态？看过：     &lt;- 看到的光 }
	    &lt;- compare_prints(-&gt; top)
	
	* (dobed) [床...]
	    床低到地面，但不是那么低，下面可能不会滚动。它仍然做得很整齐。
	    〜到达（整齐地）
	    - - (床头柜)
	    * * [掀起床罩]
	            我掀开床罩。下面的羽绒被弄皱了。
	            〜到达（crumpled_duvet）
	            ~ BedState = cover_shifted
	    * * (发现) {reached(crumpled_duvet)}
	            [取下盖子]
	            小心不要打扰下面的任何东西，我完全取下了盖子。下面的羽绒被弄皱了。
	            不是女仆的工作，她认真到了一定程度。显然，这是匆忙提出的。
	            〜到达（hastily_remade）
	            ~ BedState = cover_off
	    * * (羽绒被) {BedState == cover_off} [拉回羽绒被]
	            我把羽绒被拉了回来。在它下面是一张床单，上面粘着血。
	            ~ BedState = bloodstain_visible
	            〜到达（body_on_bed）
	            要么尸体在被拖到地板上之前被移到这里——要么这就是谋杀发生的地方。
	    * * {BedState ！？ made_up} [重新整理床]
	            我小心翼翼地将床单拉回原位，试图让它看起来不受干扰。
	            ~ BedState = made_up
	    * * [测试床]
	            我张开手指推着床。它吱吱作响，但并没有令人讨厌。
	    * * (darkunder) [看看床底下]
	            躺下，我在床底下张望，却什么也看不出来。
	
	    * * {TURNS_SINCE(-&gt; dobed) &gt; 1} [还有别的吗？]
	            我从床上退了一步，环顾四周。
	            -&gt; 顶部
	    - - -&gt; 床头柜
	
	* {darkunder &amp;&amp;卧室LightState ? on_floor &amp;&amp;卧室灯状态？上}
	    [看床底下]
	    我往床底下看了看。有什么东西闪过我。
	    - - （到达）
	    * * [伸手去拿]
	            我用一只胳膊在床底下钓鱼，但不管它是什么，它都被踢得太远了，我的手指都抓不着。
	            -&gt; 到达
	    * *     {存货 ？拐杖} [用拐杖敲它]
	            -&gt; knock_with_cane
	
	    * * {reaching &gt; 1 } [ 站起来 ]
	            我再次站起身来，拂去外套。
	            -&gt; 顶部
	
	* (knock_with_cane) {reaching &amp;&amp; TURNS_SINCE(-&gt;reaching) &gt;= 4 &amp;&amp; 库存？拐杖 } [用拐杖伸到床底下]
	    将手杖放在地毯上方，我用力敲了敲闪闪发光的东西。它从床脚底下滑了出来。
	    ~ move_to_supporter(knifeState, on_floor)
	    * * (站起来) [站起来]
	            心满意足的我站起身来，发现自己已经敲掉了一把血淋淋的刀。
	            -&gt; 顶部
	
	    * * [再看看床底下]
	            将手杖移到一边，我再次向床底望去，但那里什么也没有。
	            -&gt; 站立
	
	* {刀状态？ on_floor} [拿起刀]
	    小心不要碰把手，我从地毯上提起刀片。
	    〜得到（刀）
	
	*   {存货 ？刀}【看刀】
	    血已经够干了。干燥到足以显示刀柄上的部分印花！
	    〜到达（prints_on_knife）
	
	*   [   办公桌...]
	    我把注意力转向书桌。一个角落里放着一盏灯，另一个角落里放着一个整洁的空盘子。没有别的了。
	    靠在桌子上的是一根木拐杖。
	    ~ 卧室灯光状态 += 见过
	
	    - - （桌面状态）
	    * * (pickup_cane) {库存！？拐杖} [拿起拐杖]
	            〜得到（甘蔗）
	          我拿起木杖。它很重，而且没有标记。
	
	    * * { 卧室灯状态！？ on } [开灯]
	            -&gt; 操作灯 -&gt;
	
	    * * [看托盘]
	            我看了看里面的托盘，但什么也看不见。要么是受害者的文件被拿走了，要么他的工作已经严重枯竭。或者收件箱都是为了展示。
	
	    + + (open) {open &lt; 3} [打开抽屉]
	            我尝试了{随机抽屉|另一个抽屉|第三个抽屉}。{已锁定|也已锁定|不出所料，也已锁定}。
	
	    * * {deskstate &gt;= 2} [还有别的吗？]
	            我再次从办公桌前退了一步。
	            -&gt; 顶部
	
	    - - -&gt; 桌面状态
	
	* {(Inventory ? cane) &amp;&amp; TURNS_SINCE(-&gt; desktopstate) &lt;= 2} [Swoosh the cane]
	    我还拄着拐杖：我给了它一个实验性的旋风。它确实很重，虽然还不足以用作大棒。
	    但它可能对自卫有用。为什么受害者没有伸手去拿？打翻了吗？
	
	*   [窗户...]
	    我走到窗前向外张望。从房子旁边流下来的小溪惨淡的景象。
	
	    - - (window_opts)
	    &lt;- compare_prints(-&gt; window_opts)
	    * * (downy) [低头看小溪]
	            {玻璃状态？蒸熟：
	                透过热气腾腾的玻璃，我看不到小溪。-&gt; see_prints_on_glass -&gt; window_opts
	            }
	            我看了一会儿小溪流过。房子可能潮湿，但除此之外，它什么也没告诉我。
	    * *（油腻）[看玻璃]
	            {玻璃状态？蒸熟：-&gt; 柔和的}
	            窗户上的玻璃很油腻。有一阵子没有人清理过它，不管是里面还是外面。
	    * * { 玻璃状态？蒸的&amp;&amp;不看玻璃的&amp;&amp;软软的&amp;&amp;油腻}
	            [看蒸汽]
	            外面寒冷的一天。自然我的呼吸应该是蒸汽。-&gt; see_prints_on_glass -&gt;
	    + + {玻璃状态？ steam_gone} [对着玻璃呼吸]
	            我再次轻轻地在玻璃上呼吸。{达到（fingerprints_on_glass）：指纹又出现了。}
	            ~ GlassState = 蒸熟
	
	    + + [还有什么？]
	            { window_opts &lt; 2 ||到达 (fingerprints_on_glass) ||玻璃状态？蒸熟：
	                我把目光从沉闷的玻璃上移开。
	                {玻璃状态？蒸熟：
	                    ~ GlassState = steam_gone
	                    &lt;&gt; 我呼吸的蒸汽消退了。
	                }
	                -&gt; 顶部
	            }
	            我靠在玻璃上。我的呼吸使玻璃稍微蒸腾了一下。
	           ~ GlassState = 蒸熟
	
	    - - -&gt; window_opts
	
	* {top &gt;= 5} [离开房间]
	    我已经看够了。我{卧室灯状态？ on:关掉灯，然后}转身离开房间。
	    -&gt; joe_in_hall
	
	- -&gt; 顶部


​​​	
​ = 操作灯
​ 我轻弹电灯开关。
​ { 卧室灯光状态？上：
​ &lt;&gt; 灯泡变暗了。
​ ~ 卧室灯光状态 += 关闭
​ ~ 卧室灯光状态 -= 开启
​ - 否则：
​ { 卧室灯光状态？在地上：&lt;&gt; 床底下透出一点光。}{卧室灯状态？ on_desk ：&lt;&gt; 光在抛光的桌面上闪闪发光。}
​ ~ 卧室灯光状态 -= 关闭
​ ~ 卧室灯光状态 += 开启
​ }
​ -&gt;-&gt;


​​​	
​ = compare_prints (-&gt; backto)
​ * { 之间（（fingerprints_on_glass，prints_on_knife），fingerprints_on_glass_match_knife）} 
​ [比较刀和窗上的印花]
​ 将血淋淋的小刀举在窗边，我呼出一口气，再次拿出了那些印记，尽可能地比较了它们。
几乎不科学，但它们看起来非常相似——确实非常相似。
​ ~ 到达（fingerprints_on_glass_match_knife）
​ -&gt; 返回
​​​	
	= see_prints_on_glass
	    〜到达（fingerprints_on_glass）
	    {但我能看到一些指纹，好像有人用手掌按过一样。|指纹很清晰，形状很好。}我看着它们消失了。
	    ~ GlassState = steam_gone
	    -&gt;-&gt;
	
	= 看到的光
	    * {卧室灯状态！？ on} [开灯]
	        -&gt; 操作灯 -&gt;
	
	    * {卧室灯状态！？ on_bed &amp;&amp; BedState ?血迹_可见}
	        [把灯移到床边]
	        ~ move_to_supporter(bedroomLightState, on_bed)
	
	        我把灯移到血迹上，仔细地凝视着它。它已经深深地浸入了棉布的纤维中。
	        毫无疑问。这是受到打击的地方。
	        〜到达（murdered_in_bed）
	
	    * {卧室灯状态！？ on_desk } {TURNS_SINCE(-&gt; floorit) &gt;= 2 }
	        [将灯移回桌子]
	        ~ move_to_supporter(bedroomLightState, on_desk)
	        我把灯移回桌子，把它放在原来的位置。
	    *（地板）{卧室灯状态！？ on_floor &amp;&amp; 暗下 }
	        [把灯移到地板上]
	        ~ move_to_supporter(bedroomLightState, on_floor)
	        我拿起灯，把它放在地板上。
	    - -&gt; 顶部
	
	=== joe_in_hall
	    我的警察联系人乔正在大厅里等着。&#39;所以？&#39;他问道。“你有没有发现什么有趣的东西？”
	- （成立）
	    * {found == 1} &#39;什么都没有。&#39;
	        他耸了耸肩。&#39;耻辱。&#39;
	        -&gt; 完成
	    *   { 存货 ？ &#39;刀}&#39;我找到了凶器。
	        “干得好！”乔笑着回答。“我们认为凶手已经摆脱了它。我现在给你打包。
	        ~ move_to_supporter(knifeState, with_joe)
	
	    * {达到（prints_on_knife）} {刀状态？与乔}
	        “刀刃上有印记[。”]，我告诉他。
	        他仔细打量着他们。
	        &#39;嗯。不是很完整。很难从这些中得到匹配。
	        〜到达（joe_seen_prints_on_knife）
	    * {达到（（fingerprints_on_glass_match_knife，joe_seen_prints_on_knife））}
	        “它们也与窗户上的一组印刷品相匹配。”
	        “任何人都可能碰过窗户，”乔若有所思地回答。“但如果他们更完整，他们应该会帮助我们获得一场体面的比赛！”
	        〜到达（joe_wants_better_prints）
	    * {之间（body_on_bed，被谋杀的_in_bed）}
	        “尸体在某个时候被移到了床上[。”]，我告诉他。“然后回到地板上。”
	        &#39;为什么？&#39;
	        * *     &#39;我不知道。&#39;
	                乔点点头。&#39;好的。&#39;
	        * * &#39;也许是从地板上拿东西？&#39;
	                “你不会为此移动整个身体。”
	        * * “也许他是在床上被杀的。”
	                “目前这只是猜测，”乔评论道。
	    * {达到（谋杀床）}
	        “受害者在床上被谋杀，然后尸体被移到地板上。”
	        &#39;为什么？&#39;
	        * *     &#39;我不知道。&#39;
	                乔点点头。&#39;那好吧。&#39;
	        * * “也许凶手想误导我们。”
	                &#39;怎么会这样？&#39;
	            * * * &#39;他们想让我们认为受害者是醒着的[。&#39;]，我若有所思地回答。“他们是在与袭击者会面，而不是在睡梦中被刺伤。”
	            * * * &#39;他们想让我们认为存在某种斗争[。&#39;]，&#39;我回答。“受害者不仅仅是在睡梦中被刺伤。”
	            - - - &#39;但如果他们在床上被杀，那很可能就是这样。睡觉时被刺伤。
	                    ~ 到达 (murdered_while_asleep)
	        * * “也许凶手希望清理现场。”
	                “但他们被打扰了？这是可能的。&#39;
	
	    * { found &gt; 1} &#39;就是这样。&#39;
	        &#39;好的。这是一个开始，”乔回答道。
	        -&gt; 完成
	    - -&gt; 找到
	-   （完毕）
	    {
	    - 之间（joe_wants_better_prints，joe_got_better_prints）：
	        〜到达（joe_got_better_prints）
	        &lt;&gt; &#39;我现在就从窗户里拿到那些照片。&#39;
	    - 到达（joe_seen_prints_on_knife）：
	        &lt;&gt; &#39;我会尽我所能打印这些照片。&#39;
	    - 别的：
	        &lt;&gt; &#39;没什么可继续的。&#39;
	    }
	    -&gt; 结束



## 8) 总结

总结一个困难的部分，**ink** 的列表构造提供：

### 标志
* 每个列表条目都是一个事件
* 使用 `+=` 将事件标记为已发生
* 使用 `?` 和 `!?` 进行测试

例子：

	LIST GameEvents = foundSword、openedCasket、metGorgon
	{游戏事件？打开棺材}
	{游戏事件？（foundSword，metGorgon）}
	~ GameEvents += metGorgon

### 状态机
* 每个列表条目是一个状态
* 使用`=`设置状态； `++` 和 `--` 前进或后退
* 使用 `==`、`&gt;` 等进行测试

例子：

	LIST PancakeState =成分_聚集，面糊_混合，pan_hot，煎饼_投掷，准备好吃
	{ PancakeState == 面糊混合}
	{ 煎饼状态 &lt; 准备好吃 }
	~ PancakeState++

＃＃＃ 特性
* 每个列表都是一个不同的属性，具有属性可以采用的状态值（开或关、点亮或未点亮等）
* 通过删除旧状态更改状态，然后添加新状态
* 使用 `?` 和 `!?` 进行测试

例子：

	LIST OnOffState = 开、关
	LIST ChargeState = 未充电、充电、充电
	
	VAR PhoneState =（关闭，未充电）
	
	* {手机状态！？ uncharged } [插入手机]
		~ PhoneState -= LIST_ALL(ChargeState)
		~ PhoneState += 充电
		你把手机插上充电。
	* {电话状态？（开，充电）} [给我妈妈打电话]




# 第 6 部分：标识符中的国际字符支持

默认情况下，ink 对故事内容中非 ASCII 字符的使用没有限制。但是，目前存在限制
关于可用于常量、变量、拼接、转移和其他命名流元素（又名*标识符*）的名称的字符。

有时，使用非 ASCII 语言编写故事的作者很不方便，因为他们必须不断切换到 ASCII 中的命名标识符，然后再切换回他们用于故事的任何语言。此外，以作者自己的语言命名标识符可以提高原始故事格式的整体可读性。

为了帮助解决上述情况，ink *自动*支持可用作标识符的预定义非 ASCII 字符范围列表。通常，已选择这些范围以包括官方 unicode 字符范围的字母数字子集，这足以命名标识符。以下部分提供了有关 ink 自动支持的非 ASCII 字符的更多详细信息。

### 支持的标识符字符

当前对ink中附加字符范围的支持仅限于一组预定义的字符范围。

以下是当前支持的标识符范围的列表。

 - **阿拉伯语**

   启用阿拉伯语家族语言的字符，并且是官方 *Arabic* unicode 范围 `\u0600`-`\u06FF` 的子集。


 - **亚美尼亚人**

   启用亚美尼亚语字符，是官方 *Armenian* unicode 范围 `\u0530`-`\u058F` 的子集。


 - **西里尔文**

   为使用西里尔字母的语言启用字符，并且是官方 *Cyrillic* unicode 范围 `\u0400`-`\u04FF` 的子集。


 - **希腊语**

   为使用希腊字母的语言启用字符，并且是官方 *Greek 和 Coptic* unicode 范围 `\u0370`-`\u03FF` 的子集。


 - **希伯来语**

   使用希伯来字母启用希伯来语字符，并且是官方 *Hebrew* unicode 范围 `\u0590`-`\u05FF` 的子集。


 - **拉丁扩展 A**

   启用拉丁字母的扩展字符范围子集 - 完全由官方 *Latin Extended-A* unicode 范围 `\u0100`-`\u017F` 表示。


 - **拉丁扩展 B**

   启用拉丁字母的扩展字符范围子集 - 完全由官方 *Latin Extended-B* unicode 范围 `\u0180`-`\u024F` 表示。

- **拉丁语 1 补充**

   启用拉丁字母的扩展字符范围子集 - 完全由官方 *Latin 1 Supplement* unicode 范围 `\u0080` - `\u00FF` 表示。


**注意！** ink文件应以 UTF-8 格式保存，以确保支持上述字符范围。

如果不支持您想在标识符中使用的特定字符范围，请随时打开 [issue](/inkle/ink/issues/new) 或 [pull request](/inkle/ink/pulls)主要的ink回购。